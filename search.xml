<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>test</title>
      <link href="/2018/07/01/test/"/>
      <url>/2018/07/01/test/</url>
      <content type="html"><![CDATA[<p>test</p><a id="more"></a><p>gg</p>]]></content>
      
      
        <tags>
            
            <tag> test </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>在hexo中展示markdown文件中的图片</title>
      <link href="/2017/07/26/%E5%9C%A8hexo%E4%B8%AD%E5%B1%95%E7%A4%BAmarkdown%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/"/>
      <url>/2017/07/26/%E5%9C%A8hexo%E4%B8%AD%E5%B1%95%E7%A4%BAmarkdown%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87/</url>
      <content type="html"><![CDATA[<p>使用本地路径：在hexo/source目录下新建一个img文件夹，将图片放入该文件夹下，插入图片时链接即为/img/图片名称。<br>使用微博图床，地址<a href="http://weibotuchuang.sinaapp.com/" target="_blank" rel="external">http://weibotuchuang.sinaapp.com/</a>，将图片拖入区域中，会生成图片的URL，这就是链接地址。</p>]]></content>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>jQuery中常用的属性方法</title>
      <link href="/2017/04/21/JQ%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E5%B1%9E%E6%80%A7%E6%96%B9%E6%B3%95/"/>
      <url>/2017/04/21/JQ%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E5%B1%9E%E6%80%A7%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<p> 闲来无事把jquery中最常用的方法来整理一下！</p><a id="more"></a><h2 id="1-回调函数集合"><a href="#1-回调函数集合" class="headerlink" title="1.回调函数集合"></a>1.回调函数集合</h2><p>$.Callbacks()<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params">a</span>) </span>&#123;<span class="built_in">console</span>.log(<span class="string">"f1:"</span> + a);&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params">a,b</span>) </span>&#123;<span class="built_in">console</span>.log(<span class="string">"f2:"</span> + a + b);&#125;</div><div class="line">f1(<span class="number">1</span>);</div><div class="line">f2(<span class="number">1</span>,<span class="number">1</span>);</div><div class="line"><span class="keyword">var</span> $call=$.Callbacks();<span class="comment">//回掉函数集合</span></div><div class="line">$call.add(f1);</div><div class="line">$call.add(f1,f2);<span class="comment">//向回掉函数集合中增加方法</span></div><div class="line">$call.fire(<span class="number">1</span>,<span class="number">2</span>);<span class="comment">//fire去依次执行里面的函数,可以给传参数,函数执行的时候自动获取对应的参数</span></div><div class="line">$call.remove(f1);<span class="comment">//删除回掉函数集合中的f1方法</span></div><div class="line"><span class="built_in">console</span>.log($call.has(f1));<span class="comment">//false</span></div><div class="line"><span class="comment">//has判断回掉函数集合中有没有这个函数</span></div><div class="line"><span class="comment">//$call.empty();//清空回掉函数集合中的所有函数</span></div></pre></td></tr></table></figure></p><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><ul><li>add(f1,f2)向回调函数集合中增加方法,增加多个时用”,”隔开</li><li>fire(1,3)依次执行增加到回调函数集合中的函数,可以给传参数,函数执行的时候自动获取对应的参数</li><li>remove(f1,f2)删除向回调函数集中添加的方法,删除多个方法用”,”隔开</li><li>has(f1)判断回调函数集合中有没有这个函数,多个参数用”,”隔开.</li><li>empty()清空集合中错有自己添加进去的函数.</li></ul><h2 id="2-属性"><a href="#2-属性" class="headerlink" title="2.属性"></a>2.属性</h2><h3 id="attr-获取-设置属性"><a href="#attr-获取-设置属性" class="headerlink" title="attr(),获取/设置属性"></a>attr(),获取/设置属性</h3><p>一般都是自定义属性,会显示在html标签上</p><ul><li>一个参数是获取值</li><li>两个参数是设置属性值</li><li>参数可以是一个对象—&gt;批量设置属性值</li></ul><h3 id="removeAttr-移除属性"><a href="#removeAttr-移除属性" class="headerlink" title="removeAttr(),移除属性"></a>removeAttr(),移除属性</h3><p><code>$(&quot;#box&quot;).removeAttr(&quot;a&quot;)</code>删除单个<br><code>$(&quot;#box&quot;).removeAttr(&quot;a b&quot;)</code>移除多个属性,属性之间用空格隔开.</p><h3 id="prop-获取-设置属性"><a href="#prop-获取-设置属性" class="headerlink" title="prop(),获取/设置属性"></a>prop(),获取/设置属性</h3><p>一般都是自带的内置属性</p><blockquote><p>如果设置的是内置属性就会显示在html结构上,如果是自定义 属性不会显示在html就够上</p></blockquote><h2 id="3-class类名操作"><a href="#3-class类名操作" class="headerlink" title="3.class类名操作"></a>3.class类名操作</h2><ul><li>addClass<br>可以同时添加多个类名,类名与类名之间用空格隔开</li><li>removeClass</li><li>toggleClass</li><li>hasClass<h2 id="4-关于jQ中遍历的方法"><a href="#4-关于jQ中遍历的方法" class="headerlink" title="4.关于jQ中遍历的方法"></a>4.关于jQ中遍历的方法</h2><h3 id="each"><a href="#each" class="headerlink" title="each()"></a>each()</h3>遍历jQ集合的(和数组中的forEach很像)</li><li>参数是个函数这个函数默认执行的时候给他传了两个参数,第一个是索引(index),第二个是当前项(item是一个原生对象)<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">$(<span class="string">"#oUl&gt;li"</span>).each(<span class="function"><span class="keyword">function</span> (<span class="params">index,item</span>) </span>&#123;</div><div class="line">       <span class="comment">//this是当前的item</span></div><div class="line">       <span class="comment">//item 原生对象</span></div><div class="line">        <span class="comment">//给每个li增加一个class名"JQ"</span></div><div class="line">        $(item).addClass(<span class="string">"JQ"</span>);</div><div class="line">        <span class="comment">//$(this).addClass("JQ");</span></div><div class="line">        item.innerHTML++;</div><div class="line">        <span class="comment">//this.innerHTML++;</span></div><div class="line">        item.className+=<span class="string">" JQ"</span></div><div class="line">    &#125;)</div></pre></td></tr></table></figure></li></ul><h3 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h3><p>跟each一样,只是他有返回值<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> $map=$(<span class="string">"#oUl&gt;li"</span>).map(<span class="function"><span class="keyword">function</span> (<span class="params">index,item</span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(index, item);</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.innerHTML;</div><div class="line">    &#125;)</div></pre></td></tr></table></figure></p><blockquote><p>作为参数的函数中this是当前项即item,item是个原生对象,所以this也是,如果想使用jQ方法就要将其转为jQ对象—&gt;$(this)</p></blockquote><h2 id="5-css-样式"><a href="#5-css-样式" class="headerlink" title="5. css()样式"></a>5. css()样式</h2><p>获取/设置样式,可以批量设置</p><h2 id="6-尺寸属性"><a href="#6-尺寸属性" class="headerlink" title="6.尺寸属性"></a>6.尺寸属性</h2><p>全部都<strong>没有单位</strong></p><h3 id="offset"><a href="#offset" class="headerlink" title="offset()"></a>offset()</h3><p>当前元素距离body的偏移量,返回值是一个对象<code>{left:&quot;距离&quot;,top:&quot;距离&quot;}</code><br>offset().top/offset.left,没有单位</p><h3 id="scro-llTop-scrollLeft"><a href="#scro-llTop-scrollLeft" class="headerlink" title="scro llTop()/scrollLeft ()"></a>scro llTop()/scrollLeft ()</h3><p>不传参数是获取,传参数是修改,没有单位</p><h3 id="width-height"><a href="#width-height" class="headerlink" title="width()/height()"></a>width()/height()</h3><p>不传参数是获取,传参数是修改.没有单位 </p><h3 id="innerWidth-innerHeight"><a href="#innerWidth-innerHeight" class="headerlink" title="innerWidth()/innerHeight()"></a>innerWidth()/innerHeight()</h3><p>跟原生的client系列一样<br>不传参数是获取,传参数是修改(改的是宽高,padding不变) </p><h3 id="outerWidth-outerHeight"><a href="#outerWidth-outerHeight" class="headerlink" title="outerWidth()/outerHeight()"></a>outerWidth()/outerHeight()</h3><p>相当于offset系列(offsetWidth/offsetHeight)<br>不传参数是获取,传参数是修改,修改的时候padding+border不变,改变的是宽高.</p><blockquote><p>注意:outerWidth(true)/outerHeight(true),是获取并且加上margin.</p></blockquote><h2 id="7-文档处理"><a href="#7-文档处理" class="headerlink" title="7.文档处理"></a>7.文档处理</h2><h3 id="append"><a href="#append" class="headerlink" title="append"></a>append</h3><p><code>父级.append(新元素)</code>加在父级元素中的最后面<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> oDiv=<span class="built_in">document</span>.createElement(<span class="string">"div"</span>);</div><div class="line">    $(<span class="string">".box1"</span>).append(oDiv);<span class="comment">//添加的元素可以是原生对象</span></div><div class="line">    $(<span class="string">".box1"</span>).append($(<span class="string">"#p1"</span>));<span class="comment">//也可以是jQ对象</span></div></pre></td></tr></table></figure></p><h3 id="appendTo"><a href="#appendTo" class="headerlink" title="appendTo"></a>appendTo</h3><p>新元素.appendTo(父级)<br><code>$(&quot;#p1&quot;).appendTo(&quot;.box&quot;);</code></p><h3 id="prepend-prependTo"><a href="#prepend-prependTo" class="headerlink" title="prepend/prependTo"></a>prepend/prependTo</h3><p>加在父级元素中的最前面<br><code>$(&quot;#box&quot;).prepend($(&quot;#p1&quot;));</code><br><code>$(&quot;#p1&quot;).prependTo$(&quot;#box&quot;)</code></p><h3 id="after-before"><a href="#after-before" class="headerlink" title="after/before"></a>after/before</h3><p>加在当前元素的后面/前面<br><code>$(&quot;.box&quot;).after($(&quot;#p1&quot;));</code></p><h3 id="insertBefore-insertAfter"><a href="#insertBefore-insertAfter" class="headerlink" title="insertBefore/insertAfter"></a>insertBefore/insertAfter</h3><p>jQ选择出来的元素.insertBefore(指定元素)<br>jQ选择出来的元素.insertAfter(指定素)</p><h3 id="replaceAll"><a href="#replaceAll" class="headerlink" title="replaceAll"></a>replaceAll</h3><p><code>$(&quot;.box1&quot;).replaceAll(&quot;#p1&quot;);</code>将#p1元素替换成.box1元素</p><h3 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h3><p><code>$(&quot;div&quot;).remove(&quot;.box1&quot;);</code>把所有div中类名是box1的删掉</p><h2 id="筛选"><a href="#筛选" class="headerlink" title="筛选"></a>筛选</h2><h3 id="eq-first-last"><a href="#eq-first-last" class="headerlink" title="eq(),first(),last()"></a>eq(),first(),last()</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> $li=$(<span class="string">"ul&gt;li"</span>);</div><div class="line">   $li[<span class="number">0</span>];<span class="comment">//元素 原生对象</span></div><div class="line">   $li.eq(<span class="number">0</span>);<span class="comment">//JQ对象</span></div><div class="line">   $li.first(<span class="number">0</span>);<span class="comment">//JQ对象</span></div><div class="line">   $li.last(<span class="number">0</span>);<span class="comment">//JQ对象</span></div></pre></td></tr></table></figure><h3 id="filter同级过滤"><a href="#filter同级过滤" class="headerlink" title="filter同级过滤"></a>filter同级过滤</h3><p><code>$(&quot;ui&gt;li&quot;).filter(&quot;.li1&quot;);</code>在所有的li中找类名是li1的li元素</p><h3 id="子级过滤"><a href="#子级过滤" class="headerlink" title="子级过滤"></a>子级过滤</h3><p><code>$(&quot;ul&quot;).children(&quot;.li1&quot;);</code>在ul下找类名是li1的孩子元素</p><h3 id="后代过滤"><a href="#后代过滤" class="headerlink" title="后代过滤"></a>后代过滤</h3><p><code>$(&quot;ul&quot;).find(&quot;.li1&quot;);</code>在ul后代中找类名是li1的后代</p><h2 id="DOM操作"><a href="#DOM操作" class="headerlink" title="DOM操作"></a>DOM操作</h2><h3 id="parent-parents"><a href="#parent-parents" class="headerlink" title="parent()/parents()"></a>parent()/parents()</h3><p><code>$(&quot;.box1&quot;).parent();</code>一个父级元素<br><code>$(&quot;.box1&quot;).parents();</code>所有的父级元素(父亲,父亲的父亲…..)</p><h3 id="next-prev"><a href="#next-prev" class="headerlink" title="next(),prev()"></a>next(),prev()</h3><p>分别是下一个弟弟和上一个哥哥</p><h3 id="nextAll-prevAll"><a href="#nextAll-prevAll" class="headerlink" title="nextAll(),prevAll()"></a>nextAll(),prevAll()</h3><p>分别是所有的弟弟和所有的哥哥</p><h3 id="siblings"><a href="#siblings" class="headerlink" title="siblings()"></a>siblings()</h3><p>所有的兄弟</p><h2 id="JQ中常用的动画方法"><a href="#JQ中常用的动画方法" class="headerlink" title="JQ中常用的动画方法"></a>JQ中常用的动画方法</h2><p>在JQ中加动画的时候,在加动画之前先执行以下stop(),因为先要停止上一个动画去开启下一个动画</p><h3 id="hide-show-隐藏-显示"><a href="#hide-show-隐藏-显示" class="headerlink" title="hide()/show()隐藏/显示"></a>hide()/show()隐藏/显示</h3><p><code>$box.stop().hide();</code><br><code>$box.stop().show();</code><br>参数可以是”slow”,”fast”,”数字’</p><h3 id="slideUp-slideDown-收起来-展开"><a href="#slideUp-slideDown-收起来-展开" class="headerlink" title="slideUp()/slideDown()收起来/展开"></a>slideUp()/slideDown()收起来/展开</h3><p><code>$box.stop().slideUp();</code><br><code>$box.stop().slideDown();</code><br>参数可以是”slow”,”fast”,”数字’</p><h3 id="fadeIn-fadeOut-淡入淡出"><a href="#fadeIn-fadeOut-淡入淡出" class="headerlink" title="fadeIn()/fadeOut 淡入淡出"></a>fadeIn()/fadeOut 淡入淡出</h3><p><code>$box.stop().fadeIn();</code><br><code>$box.stop().fadeOut();</code><br>参数可以是”slow”,”fast”,”数字’</p><h3 id="fadeToggle-自动淡入淡出"><a href="#fadeToggle-自动淡入淡出" class="headerlink" title="fadeToggle()自动淡入淡出"></a>fadeToggle()自动淡入淡出</h3><h3 id="delay-时间-延迟动画"><a href="#delay-时间-延迟动画" class="headerlink" title="delay(时间)延迟动画"></a>delay(时间)延迟动画</h3><p><code>$box.stop().delay(3000).slideDown()</code><br>对hide()和show()没有效果</p><h3 id="animate-目标值-duration-回调函数function"><a href="#animate-目标值-duration-回调函数function" class="headerlink" title="animate({目标值},duration,回调函数function)"></a>animate({目标值},duration,回调函数function)</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">$box.animate(&#123;<span class="attr">top</span>:<span class="number">600</span>,<span class="attr">height</span>:<span class="number">100</span>&#125;,<span class="number">2000</span>,<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line"><span class="comment">//this当前执行动画的元素</span></div><div class="line"><span class="keyword">this</span>.innerHTML=<span class="string">"哈哈"</span></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>);</div><div class="line">$(<span class="keyword">this</span>).css(<span class="string">"backgroundColor"</span>,<span class="string">"red"</span>);</div><div class="line">$(<span class="keyword">this</span>).animate(&#123;<span class="attr">top</span>:<span class="number">80</span>,<span class="attr">height</span>:<span class="number">50</span>&#125;,<span class="number">2000</span>,<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line"><span class="keyword">this</span>.innerHTML=<span class="string">""</span>;</div><div class="line">$(<span class="keyword">this</span>).css(<span class="string">"backgroundColor"</span>,<span class="string">"yellowgreen"</span>);</div><div class="line">&#125;)</div><div class="line">&#125;);</div></pre></td></tr></table></figure><h2 id="JQ中的小技巧"><a href="#JQ中的小技巧" class="headerlink" title="JQ中的小技巧"></a>JQ中的小技巧</h2><h3 id="鼠标右键的禁用"><a href="#鼠标右键的禁用" class="headerlink" title="鼠标右键的禁用"></a>鼠标右键的禁用</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$(<span class="built_in">document</span>).contextmenu(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>);<span class="comment">//document</span></div><div class="line"><span class="comment">//return false是阻止事件默认行为的方法</span></div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span></div><div class="line">&#125;);</div><div class="line">$(<span class="string">"a"</span>)[<span class="number">0</span>].onclick=<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line"><span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">//阻止a标签的默认跳转行为</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><h3 id="鼠标的键值"><a href="#鼠标的键值" class="headerlink" title="鼠标的键值"></a>鼠标的键值</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$(<span class="string">"#box"</span>).mousedown(<span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</div><div class="line"><span class="comment">//e是事件对象</span></div><div class="line">            <span class="built_in">console</span>.log(e.which);</div><div class="line">            <span class="comment">//右键:3,左键:1,中间:2</span></div><div class="line">        &#125;);</div></pre></td></tr></table></figure><h3 id="自定义选择器"><a href="#自定义选择器" class="headerlink" title="自定义选择器"></a>自定义选择器</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> select=<span class="string">"widthMore50px"</span>;<span class="comment">//选择宽度大于50px的元素</span></div><div class="line">$.expr[<span class="string">":"</span>][select]=<span class="function"><span class="keyword">function</span> (<span class="params">a</span>) </span>&#123;</div><div class="line"><span class="comment">//return后面的是条件</span></div><div class="line"><span class="keyword">return</span> $(a).width()&gt;<span class="number">50</span>;</div><div class="line"></div><div class="line">&#125;;</div><div class="line"><span class="built_in">console</span>.log($(<span class="string">"div"</span>));</div><div class="line"><span class="built_in">console</span>.log($(<span class="string">"div:widthMore50px"</span>));</div></pre></td></tr></table></figure><h3 id="关闭动画"><a href="#关闭动画" class="headerlink" title="关闭动画"></a>关闭动画</h3><p><code>jQuery.fx.off=false</code>页面上动画有效果<br><code>jQuery.fx.off=true</code>关掉页面上动画效果<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$(<span class="string">"#box"</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    $(<span class="string">".box2"</span>).stop().slideToggle();</div><div class="line">&#125;);</div><div class="line">$(<span class="string">"#close"</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    jQuery.fx.off=<span class="literal">true</span>;</div><div class="line">&#125;);</div><div class="line">$(<span class="string">"#open"</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    jQuery.fx.off=<span class="literal">false</span>;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p><h3 id="改变this"><a href="#改变this" class="headerlink" title="改变this"></a>改变this</h3><p><code>$.proxy(函数,改变的this)</code><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.a);</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> a=<span class="number">0</span>;</div><div class="line"><span class="keyword">var</span> obj=&#123;<span class="attr">a</span>:<span class="string">"a"</span>,<span class="attr">f1</span>:f1&#125;;</div><div class="line">f1();</div><div class="line">$.proxy(f1, obj)();<span class="comment">//--&gt;输出"a";</span></div></pre></td></tr></table></figure></p>]]></content>
      
      
        <tags>
            
            <tag> jQuery </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>jQuery中的选择器</title>
      <link href="/2017/04/20/jQuery%E4%B8%AD%E7%9A%84%E9%80%89%E6%8B%A9%E5%99%A8/"/>
      <url>/2017/04/20/jQuery%E4%B8%AD%E7%9A%84%E9%80%89%E6%8B%A9%E5%99%A8/</url>
      <content type="html"><![CDATA[<h1 id="jQuery中的选择器"><a href="#jQuery中的选择器" class="headerlink" title="jQuery中的选择器"></a>jQuery中的选择器</h1><p>用jQ选择器选择出来的是个jQ对象,他只能用jQ中提供的方法,不能用原生的方法和属性</p><h3 id="如何把一个jQ对象变成原生对象"><a href="#如何把一个jQ对象变成原生对象" class="headerlink" title="如何把一个jQ对象变成原生对象"></a>如何把一个jQ对象变成原生对象</h3><ul><li>1.<code>$(&quot;#box&quot;)[0]</code></li><li>2.<code>$(&quot;#box&quot;).get(0)</code></li></ul><a id="more"></a><h3 id="把原生对象变成一个JQ对象"><a href="#把原生对象变成一个JQ对象" class="headerlink" title="把原生对象变成一个JQ对象"></a>把原生对象变成一个JQ对象</h3><p>通过JQ选择器</p><h2 id="1-基本选择器"><a href="#1-基本选择器" class="headerlink" title="1.基本选择器"></a>1.基本选择器</h2><h3 id="id选择器"><a href="#id选择器" class="headerlink" title="id选择器"></a>id选择器</h3><p><code>$(&quot;#box&quot;)</code>获取得是一个 JQ对象</p><h3 id="类选择器"><a href="#类选择器" class="headerlink" title="类选择器"></a>类选择器</h3><p><code>$(&quot;.box&quot;)</code>获取的是JQ集合</p><h3 id="通配符选择器"><a href="#通配符选择器" class="headerlink" title="通配符选择器(*)"></a>通配符选择器(*)</h3><p><code>$(&quot;*&quot;)</code>获取的是JQ集合</p><h3 id="集合选择器"><a href="#集合选择器" class="headerlink" title="集合选择器"></a>集合选择器</h3><p><code>(&quot;div,#box,p&quot;)</code>获取的是JQ集合</p><h2 id="2-层次选择器"><a href="#2-层次选择器" class="headerlink" title="2.层次选择器"></a>2.层次选择器</h2><h3 id="后代选择器"><a href="#后代选择器" class="headerlink" title="后代选择器"></a>后代选择器</h3><p><code>$(&quot;#box p&quot;)</code> 获取的是JQ集合</p><h3 id="子代选择器"><a href="#子代选择器" class="headerlink" title="子代选择器"></a>子代选择器</h3><p><code>$(&quot;#box&gt;p&quot;)</code>获取的是JQ集合</p><h3 id="弟弟选择器"><a href="#弟弟选择器" class="headerlink" title="弟弟选择器"></a>弟弟选择器</h3><h4 id="下一个弟弟选择器"><a href="#下一个弟弟选择器" class="headerlink" title="下一个弟弟选择器"></a>下一个弟弟选择器</h4><ul><li><code>$(&quot;#box+&quot;)</code>获取的是一个jQ对象</li><li><code>$(&quot;#box+div&quot;)</code>获取的是一个jQ对象(表示#box的第一个是div的弟弟)<h4 id="所有的弟弟"><a href="#所有的弟弟" class="headerlink" title="所有的弟弟"></a>所有的弟弟</h4></li><li><code>$(&quot;#box~&quot;)</code>获取所有的弟弟,是一个jQ集合</li><li><code>$(&quot;#box~div&quot;)</code>获取所有标签名为div的弟弟,是一个集合</li></ul><h2 id="3-基本过滤选择器"><a href="#3-基本过滤选择器" class="headerlink" title="3.基本过滤选择器"></a>3.基本过滤选择器</h2><h3 id="first-获取第一个元素"><a href="#first-获取第一个元素" class="headerlink" title=":first(获取第一个元素)"></a>:first(获取第一个元素)</h3><ul><li><code>$(&quot;div :first&quot;)</code>表示选取div中的第一个孩子元素,如果第一个div中没有,就去第二个div中找</li><li><code>$(&quot;div:first&quot;)</code>所有div中的第一个div<h3 id="last-获取最后一个元素"><a href="#last-获取最后一个元素" class="headerlink" title=":last(获取最后一个元素)"></a>:last(获取最后一个元素)</h3><code>$(&quot;div:last&quot;)</code>所有div中的最后一个div<h3 id="not-去除所有与给定选择器匹配的元素"><a href="#not-去除所有与给定选择器匹配的元素" class="headerlink" title=":not(去除所有与给定选择器匹配的元素)"></a>:not(去除所有与给定选择器匹配的元素)</h3><code>$(&quot;div:not(.box)&quot;)</code>class名不是box的所有div<h3 id="odd-奇数"><a href="#odd-奇数" class="headerlink" title=":odd(奇数)"></a>:odd(奇数)</h3><code>$(&quot;div:odd&quot;)</code>索引是奇数的集合<h3 id="odd-偶数"><a href="#odd-偶数" class="headerlink" title=":odd(偶数)"></a>:odd(偶数)</h3><code>$(&quot;div:even&quot;)</code>索引是偶数的集合<h3 id="eq-索引"><a href="#eq-索引" class="headerlink" title=":eq(索引)"></a>:eq(索引)</h3><code>$(&quot;div:eq(1)&quot;)</code>选取索引为1的div<h3 id="gt"><a href="#gt" class="headerlink" title=":gt"></a>:gt</h3><code>$(&quot;div:gt(2)&quot;)</code>选取索引大于2的div<h3 id="lt"><a href="#lt" class="headerlink" title=":lt"></a>:lt</h3><code>$(&quot;div:lt(2)&quot;)</code>选取索引小于2的div<h3 id="header"><a href="#header" class="headerlink" title=":header"></a>:header</h3></li></ul><p>选取所有的h(h1-h6)标签<br><code>$(&quot;.box :header&quot;)</code>类名是box的元素中所有h标签</p><h3 id="animated"><a href="#animated" class="headerlink" title=":animated"></a>:animated</h3><p>选取所有进行动画的标签(js动画,css3动画不行)</p><blockquote><p>注意:表示是指定容器下的必须加空格</p></blockquote><h2 id="4-内容过滤选择器"><a href="#4-内容过滤选择器" class="headerlink" title="4.内容过滤选择器"></a>4.内容过滤选择器</h2><h3 id="contains-“内容”"><a href="#contains-“内容”" class="headerlink" title=":contains(“内容”)"></a>:contains(“内容”)</h3><p>  <code>$(&quot;div:contains(&#39;我&#39;)&quot;)</code>所有的div中含有内容是”我”的div标签,选取的是一个jQ集合 </p><h3 id="has"><a href="#has" class="headerlink" title=":has()"></a>:has()</h3><p>  <code>$(&quot;div:has(p)&quot;)</code>所有包含p标签的div,选取的是一个jQ集合</p><h3 id="empty空元素集合"><a href="#empty空元素集合" class="headerlink" title=":empty空元素集合"></a>:empty空元素集合</h3><h3 id="parent非空集合"><a href="#parent非空集合" class="headerlink" title=":parent非空集合"></a>:parent非空集合</h3><h2 id="5-可见性过滤选择器"><a href="#5-可见性过滤选择器" class="headerlink" title="5.可见性过滤选择器"></a>5.可见性过滤选择器</h2><h3 id="hidden-隐藏元素"><a href="#hidden-隐藏元素" class="headerlink" title=":hidden 隐藏元素"></a>:hidden 隐藏元素</h3><p>display:none或者type=”hidden”匹配所有不可见元素,或者type为hidden的元素</p><h3 id="visible-可见元素"><a href="#visible-可见元素" class="headerlink" title=":visible 可见元素"></a>:visible 可见元素</h3><h2 id="6-属性过滤选择器"><a href="#6-属性过滤选择器" class="headerlink" title="6.属性过滤选择器"></a>6.属性过滤选择器</h2><ul><li><code>$(&quot;div[id]&quot;)</code>所有 有id名的div</li><li><code>$(&quot;div[class=box]&quot;)</code>所有class=box的div</li><li><code>$(&quot;div[class!=box]&quot;)</code>所有class!=box的div</li><li><code>$(&quot;div[class^=box]&quot;)</code>所有class以box开头的div</li><li><code>$(&quot;div[class$=box]&quot;)</code>所有class以box结尾的div</li><li><code>$(&quot;div[class*=box]&quot;)</code>所有class含有box的div</li><li><code>$(&quot;div[class|=box]&quot;)</code>所有class=box或者以box-作为前缀的div</li><li><code>$(&quot;div[class~=box]&quot;)</code>所有class以空格分开后的class名中真的含有box这个类名的div<h2 id="7-子元素过滤选择器"><a href="#7-子元素过滤选择器" class="headerlink" title="7.子元素过滤选择器"></a>7.子元素过滤选择器</h2></li><li><p><code>:nth-child(1)</code> 第一个孩子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$(<span class="string">"div p:nth-child(1)"</span>);</div></pre></td></tr></table></figure></li><li><p><code>:nth-child(odd)</code> 所有奇数个的孩子</p></li><li><code>:nth-child(even)</code> 所有偶数个的孩子</li><li><code>:nth-child(3n)</code>n从1开始,所有是3的倍数的孩子;</li><li>:first-child 第一个孩子</li><li>:last-child 最后一个孩子<h2 id="表单对象属性过滤器"><a href="#表单对象属性过滤器" class="headerlink" title="表单对象属性过滤器"></a>表单对象属性过滤器</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">"form1"</span> <span class="attr">action</span>=<span class="string">""</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">""</span>  <span class="attr">value</span>=<span class="string">"输入框"</span> <span class="attr">disabled</span>=<span class="string">"disabled"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"提交按钮"</span> <span class="attr">disabled</span>=<span class="string">"disabled"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">name</span>=<span class="string">""</span> <span class="attr">value</span>=<span class="string">"复选框"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">name</span>=<span class="string">""</span> <span class="attr">value</span>=<span class="string">"按钮"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">name</span>=<span class="string">""</span> <span class="attr">value</span>=<span class="string">"获取文件"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">name</span>=<span class="string">""</span> <span class="attr">value</span>=<span class="string">""</span> /&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">radio</span>&gt;</span><span class="tag">&lt;/<span class="name">radio</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">""</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"1"</span>&gt;</span>1<span class="tag">&lt;/<span class="name">option</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"2"</span>&gt;</span>2<span class="tag">&lt;/<span class="name">option</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></div></pre></td></tr></table></figure></li></ul><p><code>$(&quot;#form1 :enabled&quot;);</code>选取form1下面的所有可用元素<br><code>$(&quot;#form1 :disabled&quot;);</code>选取form1下面的所有不可用元素<br><code>$(&quot;#form1 :checked&quot;);</code>选出form1下所有被选中的元素<br><code>$(&quot;#form1 select option:selected&quot;);</code>下拉选项被选中的元素<br><code>$(&quot;#form1 :input&quot;);</code>input /textarea /select /button<br><code>$(&quot;:text&quot;);</code>所有的单行文本框<br><code>$(&quot;:password&quot;);</code>所有的密码框<br><code>$(&quot;:radio&quot;);</code>所有的单选框<br><code>$(&quot;:checkbox&quot;);</code>所有的复选框<br><code>$(&quot;:submit&quot;);</code>所有的提交按钮<br><code>$(&quot;:image&quot;);</code>所有的图片按钮<br><code>$(&quot;:button&quot;);</code>所有的按钮<br><code>$(&quot;:reset&quot;);</code>所有的重置按钮<br><code>$(&quot;:file&quot;);</code>所有的上传域<br><code>$(&quot;:hidden&quot;);</code>所有隐藏元素</p>]]></content>
      
      
        <tags>
            
            <tag> jQuery </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>MongoDB</title>
      <link href="/2017/03/11/MongoDB/"/>
      <url>/2017/03/11/MongoDB/</url>
      <content type="html"><![CDATA[<h2 id="mongodb的特点"><a href="#mongodb的特点" class="headerlink" title="mongodb的特点"></a>mongodb的特点</h2><ul><li>开源</li><li>免费</li><li>性能高(非关系数据库)</li><li>分布式<ul><li>并发量</li><li>数据量</li></ul></li><li>操作语言: javascript</li><li>缺点: 有可能丢失数据,所以安全性不是非常高</li></ul><p>分布式是指将不同的业务分布在不同的地方。 而集群指的是将几台服务器集中在一起，实现同一业务。</p><a id="more"></a><h3 id="数据库开启与关闭"><a href="#数据库开启与关闭" class="headerlink" title="数据库开启与关闭"></a>数据库开启与关闭</h3><ul><li>开启<ul><li>客户端 <code>mongo</code>  输入db检测连接是否成功</li><li>数据库端<code>mongod --dbpath=D:\Mongodb\data</code>  (D:\Mongodb\data自己创建的存储数据的空目录);如果出现<code>waiting for connections on port 27017</code>就表示<strong>启动成功</strong>,已经在27017端口上监听了客户端的请求</li></ul></li></ul><blockquote><p>注意：<strong>–dbpath后的值表示数据库文件的存储路径,而且后面的路径必须事先创建好，必须已经</strong>存在<strong>，否则服务开启失败</strong></p></blockquote><ul><li>关掉数据库 use admin;<br>db.shutdownServer();</li></ul><h2 id="mongoose"><a href="#mongoose" class="headerlink" title="mongoose"></a>mongoose</h2><ol><li>Mongoose是MongoDB的一个对象模型工具 同时它也是针对MongoDB操作的一个对象模型库,<strong>封装了MongoDB对文档的一些增删改查等常用方法</strong> 让NodeJS操作Mongodb数据库变得更加灵活简单</li></ol><h3 id="安装mongoose"><a href="#安装mongoose" class="headerlink" title="安装mongoose"></a>安装mongoose</h3><p><code>$ npm install mongoose</code></p><h3 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h3><ul><li><p>1) 引入mongoose模块:  <code>let mongoose=require(&quot;mongoose&quot;)</code></p></li><li><p>2) 返回连接对象: <code>let coon =mongoose.createConnection(&#39;mongodb://127.0.0.1/201704node&#39;)</code>(格式:monogdb://IP:端口号/数据库名称);</p></li><li><p>3) 创建数据库的骨架模型，规定集合文档中的字段名称和字段类型</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//这就是规定了集合中文档的名称为name age,类型分别是字符串和数字</span></div><div class="line"><span class="keyword">let</span> UserSchema = <span class="keyword">new</span> mongoose.Schema(&#123;</div><div class="line">  <span class="attr">name</span>:<span class="built_in">String</span>,<span class="comment">//用户名称</span></div><div class="line">  age:<span class="built_in">Number</span><span class="comment">//用户年龄</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure></li><li><p>4) 定义模型  2个参数表示定义一个模块 1个参数表示获取一个模型</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> User = conn.model(<span class="string">'User'</span>,UserSchema);</div></pre></td></tr></table></figure><h3 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h3><h4 id="增-create"><a href="#增-create" class="headerlink" title="增 create"></a>增 create</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">User.create(&#123;<span class="attr">name</span>:<span class="string">'zfpx'</span>,<span class="attr">age</span>:<span class="string">"300"</span>&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">err,doc</span>)</span>&#123;</div><div class="line">  <span class="keyword">if</span>(err)&#123;</div><div class="line">    <span class="built_in">console</span>.error(err);</div><div class="line">  &#125;<span class="keyword">else</span>&#123;</div><div class="line">    <span class="comment">//__v: 0 版本号，解决并发问题</span></div><div class="line">    <span class="comment">//_id 是文档的主键, 1.唯一的 2 没什么太多业务含义，所以永远不需要修改</span></div><div class="line">    <span class="comment">//&#123; __v: 0, name: 'zfpx', age: 8, _id: 5972c54c4735381708af182d &#125;</span></div><div class="line">    <span class="built_in">console</span>.log(doc);</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure><h4 id="删remove"><a href="#删remove" class="headerlink" title="删remove"></a>删remove</h4><p>参数1<code>{age:300}</code>是文档对象,可以是一个数组，就是条件,默认情况下回删除掉符合条件的所有的文档,不同的模型对应于不同的集合</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">User.remove(&#123;<span class="attr">age</span>:<span class="number">300</span>&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">err,result</span>)</span>&#123;</div><div class="line">  <span class="keyword">if</span>(err)&#123;</div><div class="line">    <span class="built_in">console</span>.log(err);</div><div class="line">  &#125;<span class="keyword">else</span>&#123;</div><div class="line">    <span class="comment">//&#123; ok: 1, n: 0 &#125; ok=1表示删除操作成功 n=0表示实际删除掉的条数为0</span></div><div class="line">    <span class="built_in">console</span>.log(result.result);</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure><h4 id="改-update"><a href="#改-update" class="headerlink" title="改 update"></a>改 update</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">参数1是更新的条件 参数2是更新后的值</div></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//$inc = increment 增加 在原来字段的基础上加1</span></div><div class="line">User.update(&#123;<span class="attr">_id</span>:<span class="string">'5972cc94f3ef0e1580666fa6'</span>&#125;,&#123;<span class="attr">$inc</span>:&#123;<span class="attr">age</span>:<span class="number">5</span>&#125;&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">err,result</span>)</span>&#123;</div><div class="line">  <span class="comment">//&#123; ok: 1, nModified: 1, n: 1 &#125;</span></div><div class="line">  <span class="comment">// 更新成功 实际修改的条数1 符合更新条件的条数</span></div><div class="line">  <span class="comment">//如果更新前的值和更新后的值是一样的话，那么不进行实际更新</span></div><div class="line">  <span class="built_in">console</span>.log(result);</div><div class="line">&#125;);</div></pre></td></tr></table></figure><h4 id="查-find"><a href="#查-find" class="headerlink" title="查 find"></a>查 find</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//参数1里放的是条件</span></div><div class="line"><span class="comment">//参数2里放的是要显示或排除显示的字段 &#123;字段名:1&#125;表示只显示此字段</span></div><div class="line"><span class="comment">//  &#123;字段名:0&#125; 表示只排除显示指定的字段</span></div><div class="line"><span class="comment">// 只显示name  只排除age  home</span></div><div class="line"><span class="comment">//Can't canonicalize query: BadValue Projection cannot have a mix of inclusion and exclusion.</span></div><div class="line"><span class="comment">//0 exclusion 非0 inclusion</span></div><div class="line"></div><div class="line"><span class="comment">//两个条件的或 $or</span></div><div class="line">User.find(&#123;<span class="attr">$or</span>:[&#123;<span class="attr">name</span>:<span class="string">"zfpx1"</span>&#125;,&#123;<span class="attr">name</span>:<span class="string">"zfpx2"</span>&#125;]&#125;,<span class="function"><span class="keyword">function</span> (<span class="params">err,result</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(result);</div><div class="line"> &#125;)</div><div class="line"> </div><div class="line"><span class="comment">// age &gt;2 &lt;2 &gt;=2 &lt;=2</span></div><div class="line"><span class="comment">// age $gt $lt $gte $lte</span></div><div class="line">User.find(&#123;<span class="attr">age</span>:&#123;<span class="attr">$gt</span>:<span class="number">5</span>&#125;&#125;,<span class="function"><span class="keyword">function</span> (<span class="params">err,result</span>) </span>&#123;</div><div class="line">     <span class="built_in">console</span>.log(result);</div><div class="line"> &#125;)</div><div class="line"> </div><div class="line"><span class="comment">// 模糊匹配</span></div><div class="line">User.find(&#123;<span class="attr">name</span>:<span class="regexp">/zfpx/</span>&#125;,<span class="function"><span class="keyword">function</span> (<span class="params">err,result</span>) </span>&#123;</div><div class="line">     <span class="built_in">console</span>.log(result);</div><div class="line"> &#125;)</div><div class="line"> </div><div class="line"> <span class="comment">//findOne</span></div><div class="line"> <span class="keyword">let</span> username=<span class="number">1</span>, password=<span class="number">2</span>;</div><div class="line">User.findOne(&#123;username,password&#125;,<span class="function"><span class="keyword">function</span> (<span class="params">err,doc</span>) </span>&#123;</div><div class="line">    <span class="comment">//最多只返回一条 只要查找到符合条件的记录就返回不再继续查询;</span></div><div class="line">    <span class="comment">//doc返回null,或者是一个文档对象;</span></div><div class="line">    <span class="keyword">if</span>(err)&#123;</div><div class="line">        <span class="built_in">console</span>.log(err);</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(doc);</div><div class="line">        <span class="keyword">if</span>(doc)&#123;</div><div class="line">            <span class="built_in">console</span>.log(doc);</div><div class="line">            <span class="built_in">console</span>.log(<span class="string">"登陆成功"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">//findById</span></div><div class="line">User.findById(<span class="string">'5972cc94f3ef0e1580666fa6'</span>,&#123;<span class="attr">name</span>:<span class="number">1</span>&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">err,doc</span>)</span>&#123;</div><div class="line">  &#123; <span class="attr">_id</span>: <span class="number">5972</span>cc94f3ef0e1580666fa6, <span class="attr">name</span>: <span class="string">'zfpx1'</span>, <span class="attr">age</span>: <span class="number">112</span>, <span class="attr">__v</span>: <span class="number">0</span> &#125;</div><div class="line">  <span class="built_in">console</span>.log(doc);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">let</span> pageNum=<span class="number">2</span>;<span class="comment">//当前页码</span></div><div class="line"><span class="keyword">let</span> pageSize = <span class="number">3</span>;<span class="comment">//每页的条数</span></div><div class="line"><span class="comment">//skip跳过指定的条数</span></div><div class="line"><span class="comment">//limit指定返回的最多条数</span></div><div class="line"><span class="comment">//DeprecationWarning: Mongoose: mpromise (mongoose's default promise library) is deprecated, plug in your own promise library instead</span></div><div class="line"><span class="comment">//sort指定排序的字段 age:-1 表示降序 1表示升序</span></div><div class="line"><span class="comment">//只有在调用exec的时候 才会真正向服务器发起查询</span></div><div class="line">User.find()</div><div class="line">  .limit(pageSize)</div><div class="line">  .sort(&#123;<span class="attr">age</span>:<span class="number">1</span>&#125;)</div><div class="line">  .skip((pageNum<span class="number">-1</span>)*pageSize)</div><div class="line">  .exec(<span class="function"><span class="keyword">function</span>(<span class="params">err,docs</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(docs);</div><div class="line">  &#125;)</div></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> MongoDB </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>import和export</title>
      <link href="/2016/10/11/import%20%E5%92%8Cexport/"/>
      <url>/2016/10/11/import%20%E5%92%8Cexport/</url>
      <content type="html"><![CDATA[<h2 id="ES6中的模块"><a href="#ES6中的模块" class="headerlink" title="ES6中的模块"></a>ES6中的模块</h2><p>一个单独的文件就是一个模块。每一个模块都是一个单独的作用域，在一个文件中定义的变量，都是私有的，对其他文件是不可见的。</p><p>import 和export是ES6中的模块处理方法</p><a id="more"></a><ul><li>export</li></ul><p>用于对外输出本模块(一个文件可以理解为一个模块)变量的接口</p><ul><li>import</li></ul><p>用于在一个模块中加载另一个含有export接口的模块</p><p>也就是说使用export命令定义了模块的对外接口以后,其他js文件就可以通过import命令加载这个模块(文件)</p><p>举个例子: 假设在同一个目录下有两个文件a.js和b.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// a.js</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> sex=<span class="string">"boy"</span>;</div><div class="line"><span class="keyword">var</span> echo=<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">　　<span class="built_in">console</span>.log(value)</div><div class="line">&#125;</div><div class="line"><span class="keyword">export</span> &#123;sex,echo&#125;  </div><div class="line"><span class="comment">//通过向大括号中添加sex，echo变量并且export输出，就可以将对应变量值以sex、echo变量标识符形式暴露给其他文件而被读取到</span></div><div class="line"><span class="comment">//不能写成export sex这样的方式，如果这样就相当于export "boy",外部文件就获取不到该文件的内部变量sex的值，因为没有对外输出变量接口,只是输出的字符串。</span></div></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// b.js</span></div><div class="line">通过<span class="keyword">import</span>获取a.js文件的内部变量，&#123;&#125;括号内的变量来自于a.js文件<span class="keyword">export</span>出的变量标识符。</div><div class="line"><span class="keyword">import</span> &#123;sex,echo&#125; <span class="keyword">from</span> <span class="string">"./a.js"</span> </div><div class="line"><span class="built_in">console</span>.log(sex)   <span class="comment">// boy</span></div><div class="line">echo(sex) <span class="comment">// boy</span></div></pre></td></tr></table></figure><p>通过上面的例子可以看出,b.js使用import命令的时候,用户需要知道a.js所暴露出的变量标识符,否则无法加载,可以使用export default命令,为模板指定默认输出,这样就不需要知道所要加载模块的变量名</p><p>如下: </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//a.js</span></div><div class="line"><span class="keyword">var</span> sex=<span class="string">"boy"</span>;</div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> sex（sex不能加大括号）</div><div class="line"><span class="comment">//原本直接export sex外部是无法识别的，加上default就可以了.但是一个文件内最多只能有一个export default。</span></div><div class="line">其实此处相当于为sex变量值<span class="string">"boy"</span>起了一个系统默认的变量名<span class="keyword">default</span>，自然<span class="keyword">default</span>只能有一个值，所以一个文件内不能有多个<span class="keyword">export</span> <span class="keyword">default</span>。</div></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// b.js</span></div><div class="line">本质上，a.js文件的<span class="keyword">export</span> <span class="keyword">default</span>输出一个叫做<span class="keyword">default</span>的变量，然后系统允许你为它取任意名字。所以可以为<span class="keyword">import</span>的模块起任何变量名，且不需要用大括号包含</div><div class="line"><span class="keyword">import</span> any <span class="keyword">from</span> <span class="string">"./a.js"</span></div><div class="line"><span class="keyword">import</span> any12 <span class="keyword">from</span> <span class="string">"./a.js"</span> </div><div class="line"><span class="built_in">console</span>.log(any,any12)   <span class="comment">// boy,boy</span></div></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> module </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>canvas基础</title>
      <link href="/2016/07/26/canvas/"/>
      <url>/2016/07/26/canvas/</url>
      <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>canvas 是h5新标签,在页面上绘制图形用的(通常称为画布),canvas只是一个容器,我们用js脚本来进行控制和操作</p><ul><li>获取canvas:在js中对canvas进行操作标签之前和其他的标签元素一样要先获取出来<br><code>var draw=document.getElementById(&quot;draw&quot;);</code></li><li>设置绘制环境:getContext(“2d”);2d表示在平面上进行绘制<code>var cvs=draw.getContext(&quot;2d&quot;);</code></li><li>绘制图形的两种方式:<ul><li>边框：<code>cvs.stroke()</code><ul><li>cvs.strokeStyle=”笔触颜色(边框的颜色)”</li><li>cvs.lineWidth=数值,边框的宽度</li></ul></li><li>填充:<code>cvs.fill();</code><ul><li>cvs.fillStyle=”填充的样式”;<a id="more"></a></li></ul></li></ul></li></ul><h3 id="支持的颜色书写方式"><a href="#支持的颜色书写方式" class="headerlink" title="支持的颜色书写方式"></a>支持的颜色书写方式</h3><ul><li>颜色的名字 red yellow</li><li>十六进制</li><li>三色值:rgb(123,234,120)</li><li>四色值:rgba(123,234,120,.5);<h2 id="功能操作"><a href="#功能操作" class="headerlink" title="功能操作"></a>功能操作</h2><h3 id="绘制线条"><a href="#绘制线条" class="headerlink" title="绘制线条"></a>绘制线条</h3></li><li>cvs.moveTo(x,y) 起始点的坐标,</li><li><p>cvs.lineTo(x,y)  结束点的坐标</p><blockquote><p>如果没有moveTo就把上一个挨着的lineTo作为起始坐标</p></blockquote></li><li><p>cvs.beginPath()开始一个新的路径</p></li><li>cvs.closePath();关闭当前路径,自动闭合,从结束的坐标到起始坐标自动连接<h3 id="设置线条交汇处的样式"><a href="#设置线条交汇处的样式" class="headerlink" title="设置线条交汇处的样式"></a>设置线条交汇处的样式</h3>css中的圆角border-radius,canvas中也可以实现这个效果<h4 id="lineJoin"><a href="#lineJoin" class="headerlink" title="lineJoin"></a>lineJoin</h4>cvs.lineJoin=”属性值”,他有三个属性值</li><li>尖角miter  </li><li>圆角round  </li><li>斜角bevel<h4 id="lineCap"><a href="#lineCap" class="headerlink" title="lineCap"></a>lineCap</h4>cvs.lineCap=”属性值”,他有三个属性值</li><li>butt(默认的,平的),</li><li>round(圆角), </li><li>square(方角)<blockquote><p>注意: 对于单个线条,一旦加上关上当前路径(closePath)就没有圆角的效果了;</p></blockquote></li></ul><h3 id="绘制矩形"><a href="#绘制矩形" class="headerlink" title="绘制矩形"></a>绘制矩形</h3><p>cvs.fillRect(x,y,w,h);填充的矩形</p><ul><li>x,y是这个矩形左上角的坐标</li><li>w,h这个矩形的宽和高</li></ul><blockquote><p>注意:边框一半在里面,一半在外面;</p></blockquote><h4 id="绘制矩形的两种方式"><a href="#绘制矩形的两种方式" class="headerlink" title="绘制矩形的两种方式:"></a>绘制矩形的两种方式:</h4><ul><li><code>cvs.fillRect(10,20,100,50);</code></li><li><code>cvs.strokeRect(150,20,100,50);</code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">draw1</span>(<span class="params"></span>)</span>&#123;</div><div class="line"><span class="comment">//填充方式</span></div><div class="line">cvs.fillStyle=<span class="string">"rgba(0,0,190,.5)"</span>;</div><div class="line">cvs.fillRect(<span class="number">10</span>,<span class="number">20</span>,<span class="number">100</span>,<span class="number">50</span>);</div><div class="line"><span class="comment">//边框方式</span></div><div class="line">cvs.strokeStyle=<span class="string">"rgba(190,0,0,.5)"</span>;</div><div class="line">cvs.lineWidth=<span class="number">30</span>;</div><div class="line">cvs.strokeRect(<span class="number">150</span>,<span class="number">20</span>,<span class="number">100</span>,<span class="number">50</span>);</div><div class="line"><span class="comment">//边框一半在里面,一半在外面,所以实际的坐标是165,35</span></div><div class="line"></div><div class="line">&#125;</div><div class="line">draw1();</div></pre></td></tr></table></figure></li></ul><h4 id="清除某部分"><a href="#清除某部分" class="headerlink" title="清除某部分"></a>清除某部分</h4><p>格式:<code>cvs.clearRect(x,y,w,h);</code></p><ul><li>x:left值</li><li>y:top值</li><li>w:width</li><li>h:height</li></ul><h3 id="绘制圆"><a href="#绘制圆" class="headerlink" title="绘制圆"></a>绘制圆</h3><p>格式:<code>cvs.arc(x,y,r,s,e,n)</code></p><ul><li>x,y是圆心的坐标,</li><li>r是半径,</li><li>s起始角,以弧度计算(三点钟方向是0度),</li><li>e结束角,</li><li>n:是否逆时针true/false(默认是false顺时针);<blockquote><p>注意:每次调用fill的时候,会把当次路径的起始点和结束点分别连接,填充闭合部分,所以以后每次再写路径的时候记得关闭当前路径</p></blockquote></li></ul><h3 id="渐变"><a href="#渐变" class="headerlink" title="渐变"></a>渐变</h3><h4 id="线性渐变"><a href="#线性渐变" class="headerlink" title="线性渐变"></a>线性渐变</h4><p>格式:<code>var CLG=cvs.createLinearGradient(x0,y0,x1,y1);</code><br><code>CLG.addColorStop(n,m)</code></p><ul><li>x0:渐变开始的x坐标</li><li>y0:渐变开始的y坐标</li><li>x1:渐变结束的x坐标</li><li>y1:渐变结束的y坐标</li><li>n:设置颜色的偏移量</li><li>m:颜色<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">draw1</span>(<span class="params"></span>)</span>&#123;</div><div class="line"><span class="keyword">var</span> CLG=cvs.createLinearGradient(<span class="number">0</span>,<span class="number">0</span>,<span class="number">200</span>,<span class="number">200</span>);</div><div class="line">CLG.addColorStop(<span class="number">0</span>,<span class="string">"white"</span>);</div><div class="line">CLG.addColorStop(<span class="number">0.15</span>,<span class="string">"pink"</span>);</div><div class="line">CLG.addColorStop(<span class="number">0.25</span>,<span class="string">"white"</span>);</div><div class="line">CLG.addColorStop(<span class="number">0.5</span>,<span class="string">"skyblue"</span>);</div><div class="line">CLG.addColorStop(<span class="number">0.6</span>,<span class="string">"white"</span>);</div><div class="line">CLG.addColorStop(<span class="number">0.75</span>,<span class="string">"pink"</span>);</div><div class="line">CLG.addColorStop(<span class="number">1</span>,<span class="string">"white"</span>);</div><div class="line"></div><div class="line">cvs.fillStyle=CLG;</div><div class="line">cvs.fillRect(<span class="number">0</span>,<span class="number">0</span>,<span class="number">200</span>,<span class="number">200</span>);</div><div class="line"></div><div class="line">&#125;</div><div class="line">draw1();</div></pre></td></tr></table></figure></li></ul><h4 id="径向渐变-发散性渐变"><a href="#径向渐变-发散性渐变" class="headerlink" title="径向渐变(发散性渐变)"></a>径向渐变(发散性渐变)</h4><p>格式：<code>cvs.createRadialGradient(x0,y0,r0,x1,y1,r1)</code></p><ul><li>x0:渐变开始的x坐标</li><li>y0:渐变开始的y坐标</li><li>r0:渐变开始的半径</li><li>x1:渐变结束的x坐标</li><li>y1:渐变结束的y坐标</li><li>r1:渐变结束的半径<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">unction draw2()&#123;</div><div class="line"><span class="keyword">var</span> CRG=cvs.createRadialGradient(<span class="number">480</span>,<span class="number">480</span>,<span class="number">30</span>,<span class="number">350</span>,<span class="number">350</span>,<span class="number">680</span>);</div><div class="line">CRG.addColorStop(<span class="number">0</span>,<span class="string">"white"</span>);</div><div class="line">CRG.addColorStop(<span class="number">0.15</span>,<span class="string">"pink"</span>);</div><div class="line">CRG.addColorStop(<span class="number">0.25</span>,<span class="string">"white"</span>);</div><div class="line">CRG.addColorStop(<span class="number">0.5</span>,<span class="string">"skyblue"</span>);</div><div class="line">CRG.addColorStop(<span class="number">0.6</span>,<span class="string">"white"</span>);</div><div class="line">CRG.addColorStop(<span class="number">0.75</span>,<span class="string">"pink"</span>);</div><div class="line">CRG.addColorStop(<span class="number">1</span>,<span class="string">"white"</span>);</div><div class="line">cvs.fillStyle=CRG;</div><div class="line">cvs.fillRect(<span class="number">100</span>,<span class="number">100</span>,<span class="number">400</span>,<span class="number">400</span>);</div><div class="line">&#125;</div><div class="line">draw2();</div></pre></td></tr></table></figure></li></ul><h3 id="绘图"><a href="#绘图" class="headerlink" title="绘图"></a>绘图</h3><h4 id="格式一"><a href="#格式一" class="headerlink" title="格式一"></a>格式一</h4><p><code>cvs.drawImage(Image,x,y,w,h);</code></p><ul><li>Image:就是可以放在DOM中的真实图片,可以动态创建,也可以获取页面上的</li><li>x,y 图片左上角的坐标</li><li>w,h绘制图片的宽高<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">draw1</span>(<span class="params"></span>)</span>&#123;</div><div class="line"><span class="keyword">var</span> img=<span class="keyword">new</span> Image;</div><div class="line">img.src=<span class="string">"QQ图片20170608163047.gif"</span>;</div><div class="line">img.onload=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">cvs.drawImage(<span class="keyword">this</span>,<span class="number">0</span>,<span class="number">100</span>,<span class="number">100</span>,<span class="number">75</span>)</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">draw1();</div></pre></td></tr></table></figure></li></ul><h4 id="格式二-可截取"><a href="#格式二-可截取" class="headerlink" title="格式二(可截取)"></a>格式二(可截取)</h4><p><code>cvs.drawImage(Image,sx,sy,sw,sh,dx,dy,dw,dh)</code></p><ul><li>sx,sy  图片左上角的坐标</li><li>sw,sh  矩形区域的宽高,用来截取图片;</li><li>dx,dy  截取出来放在canvas上的坐标</li><li>dw,dh  画在canvas上的宽高;</li><li>sx,sy,sw,sh是截取图片的过程</li><li>dx,dy,dw,dh是把截取出来的图片放在canvas上的过程;<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">draw2</span>(<span class="params"></span>)</span>&#123;</div><div class="line"><span class="keyword">var</span> img= <span class="keyword">new</span> Image;</div><div class="line">img.src=<span class="string">"2.jpg"</span></div><div class="line">img.onload=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">cvs.drawImage(<span class="keyword">this</span>,<span class="number">480</span>,<span class="number">150</span>,<span class="number">440</span>,<span class="number">410</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">100</span>,<span class="number">100</span>)</div><div class="line">cvs.createPattern(<span class="keyword">this</span>,<span class="string">"repeat-x"</span>)</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">draw2();</div></pre></td></tr></table></figure></li></ul><h4 id="设置平铺"><a href="#设置平铺" class="headerlink" title="设置平铺"></a>设置平铺</h4><p>格式：<code>cvs.createPattern(Image,type);</code></p><ul><li>Image:就是可以放在DOM中的真实图片,可以动态创建,也可以获取页面上的</li><li>type:no-repeat不平铺,repeat全方向平铺,</li><li>repeat-x:x轴方向平铺</li><li>repeat-y:y轴方向平铺<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">draw3</span>(<span class="params"></span>)</span>&#123;</div><div class="line"><span class="keyword">var</span> img= <span class="keyword">new</span> Image;</div><div class="line">img.src=<span class="string">"../imges/chimpified.jpeg"</span></div><div class="line">img.onload=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line"><span class="keyword">var</span> rep=cvs.createPattern(<span class="keyword">this</span>,<span class="string">"repeat"</span>);</div><div class="line">cvs.fillStyle=rep;</div><div class="line">cvs.fillRect(<span class="number">0</span>,<span class="number">0</span>,draw.width,draw.height);</div><div class="line"></div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">draw3();</div></pre></td></tr></table></figure></li></ul><h3 id="变形"><a href="#变形" class="headerlink" title="变形"></a>变形</h3><h4 id="平移"><a href="#平移" class="headerlink" title="平移"></a>平移</h4><p>格式：<code>cvs.translate(x,y)</code></p><ul><li>x:坐标原点向x轴平移的距离</li><li>y:坐标原点向y轴平移的距离<h4 id="缩放"><a href="#缩放" class="headerlink" title="缩放"></a>缩放</h4>格式：<code>cvs.scale(x0,y0);</code></li><li>x0:x轴照x0的比例缩放</li><li>x0:y轴照y0的比例缩放</li></ul><h4 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h4><p>格式：<code>cvs.rotate(angle);</code></p><ul><li>angle:坐标轴转的角度(跟画圆的弧度计算是一样的)</li></ul><p>综合案例<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">draw2</span>(<span class="params"></span>)</span>&#123;</div><div class="line">cvs.translate(<span class="number">140</span>,<span class="number">0</span>)</div><div class="line">cvs.rotate(<span class="built_in">Math</span>.PI/<span class="number">2</span>);</div><div class="line">cvs.translate(<span class="number">0</span>,<span class="number">-70</span>);</div><div class="line">cvs.scale(<span class="number">0.6</span>,<span class="number">1.1</span>);</div><div class="line">cvs.fillStyle=<span class="string">"greenyellow"</span>;</div><div class="line">cvs.fillRect(<span class="number">100</span>,<span class="number">20</span>,<span class="number">200</span>,<span class="number">70</span>);</div><div class="line">&#125;</div><div class="line">draw2();</div></pre></td></tr></table></figure></p><h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><h4 id="绘制文本"><a href="#绘制文本" class="headerlink" title="绘制文本"></a>绘制文本</h4><ul><li>1)设置字体样式：<code>cvs.font=&quot;字体大小font-size font-family&quot;</code></li><li>2）对齐方式<ul><li>水平对齐：<code>cvs.textAlign(属性值:start,end,right,center)</code></li><li>垂直对齐齐：<code>cvs.textBaseline=&quot;一个值&quot;(属值:&quot;top&quot;,middle,hanging,bottom,alphabetic,ideographic)</code></li></ul></li><li><p>3) cvs.measureText()计算文本长度(可以理解为文本的宽度，返回值是一个对象)</p></li><li><p>4）</p><ul><li>填充文字<code>cvs.fillText(text,x,y);</code></li><li>绘制文字轮廓<br><code>cvs.strokeText(text,x,y)</code></li><li>text:文本内容</li><li>x,y:文字起始点的坐标<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">draw2</span>(<span class="params"></span>)</span>&#123;</div><div class="line"><span class="keyword">var</span> text=<span class="string">"hello world"</span>;</div><div class="line">cvs.fillStyle=<span class="string">"#FFA500"</span>;</div><div class="line">cvs.font=<span class="string">"40px verdana"</span>;</div><div class="line">cvs.textAlign=<span class="string">"start"</span>;</div><div class="line">cvs.textBaseline=<span class="string">"top"</span>;</div><div class="line">cvs.fillText(text,<span class="number">0</span>,<span class="number">0</span>);</div><div class="line"><span class="keyword">var</span> length=cvs.measureText(text);</div><div class="line"><span class="built_in">console</span>.dir(length);</div><div class="line">cvs.fillText(<span class="string">"字体长度为"</span>+length.width,<span class="number">0</span>,<span class="number">50</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">draw2();</div></pre></td></tr></table></figure></li></ul></li></ul><h4 id="阴影"><a href="#阴影" class="headerlink" title="阴影"></a>阴影</h4><ul><li><code>cvs.shadowOffsetX;</code>阴影横向偏移量(默认值是0);</li><li><code>cvs.shadowOffsetY;</code>阴影的纵向偏移量(默认值是0);</li><li><code>cvs.shadowColor;</code>阴影的颜色</li><li><code>cvs.shadowBlur</code>阴影的模糊范围(值越大越模糊)</li></ul><p>附一个漂亮字体的综合案例<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">draw3</span>(<span class="params"></span>)</span>&#123;</div><div class="line"><span class="keyword">var</span> CLG=cvs.createLinearGradient(<span class="number">0</span>,<span class="number">150</span>,<span class="number">450</span>,<span class="number">250</span>);</div><div class="line"><span class="comment">//设置渐变的颜色</span></div><div class="line">CLG.addColorStop(<span class="number">0</span>,<span class="string">"pink"</span>);</div><div class="line">CLG.addColorStop(<span class="number">0.15</span>,<span class="string">"skyblue"</span>);</div><div class="line">CLG.addColorStop(<span class="number">0.2</span>,<span class="string">"orange"</span>);</div><div class="line">CLG.addColorStop(<span class="number">0.5</span>,<span class="string">"pink"</span>);</div><div class="line">CLG.addColorStop(<span class="number">0.75</span>,<span class="string">"skyblue"</span>);</div><div class="line">CLG.addColorStop(<span class="number">1</span>,<span class="string">"pink"</span>);</div><div class="line"><span class="keyword">var</span> text=<span class="string">"哈哈~~"</span>;</div><div class="line">cvs.fillStyle=CLG;</div><div class="line"><span class="comment">//设置阴影</span></div><div class="line">cvs.shadowOffsetX=<span class="number">5</span>;</div><div class="line">cvs.shadowOffsetY=<span class="number">4</span>;</div><div class="line">cvs.shadowColor=<span class="string">"#87CEEB"</span>;<span class="comment">//阴影颜色</span></div><div class="line">cvs.shadowBlur=<span class="number">5</span>;<span class="comment">//阴影模糊范围</span></div><div class="line">cvs.font=<span class="string">"40px cursive"</span>;<span class="comment">//字体设置</span></div><div class="line">cvs.textAlign=<span class="string">"start"</span>;<span class="comment">//水平对齐</span></div><div class="line">cvs.textBaseline=<span class="string">"top"</span>;<span class="comment">//垂直对齐</span></div><div class="line">cvs.fillText(text,<span class="number">20</span>,<span class="number">120</span>);<span class="comment">//导入文字</span></div><div class="line"><span class="keyword">var</span> wid=cvs.measureText(text).width; <span class="comment">//获取文字长度这个对象中的width属性的值</span></div><div class="line">cvs.fillText(<span class="string">"hahahahah"</span>+wid,<span class="number">20</span>,<span class="number">30</span>);</div><div class="line">&#125;</div><div class="line">draw3();</div></pre></td></tr></table></figure></p><h3 id="图形组合交叠样式"><a href="#图形组合交叠样式" class="headerlink" title="图形组合交叠样式"></a>图形组合交叠样式</h3><p>格式：cvs.globalCompositeOperation=type<br>type的值：<br>1.source-over:默认值 在原来的图形上绘制新图(覆盖的意思);<br>2.destination-over:在原来的图形下面绘制新图;<br>3.source-in:显示交集颜色是新图的颜色;<br>4.destination-in:显示交集,颜色是旧图的颜色;<br>5.source-out:显示新图非交集部分<br>6.destination-out:显示旧图非交集部分<br>7.source-atop:显示旧图和交集部分,交集是新图的颜色;<br>8.destination-atop:显示新图和交集部分,交集是旧图的颜色;<br>9.lighter:全部显示,交集部分是颜色的叠加<br>10.xor:显示新旧图的非交集部分<br>11.copy:只显示新图<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">draw1</span>(<span class="params"></span>)</span>&#123;</div><div class="line">cvs.fillStyle=<span class="string">"rgb(250,0,250)"</span>;</div><div class="line">cvs.fillRect(<span class="number">10</span>,<span class="number">10</span>,<span class="number">100</span>,<span class="number">100</span>);</div><div class="line">cvs.globalCompositeOperation=<span class="string">"lighter"</span>;</div><div class="line">cvs.fillStyle=<span class="string">"#449FDB"</span>;</div><div class="line">cvs.fillRect(<span class="number">50</span>,<span class="number">50</span>,<span class="number">200</span>,<span class="number">200</span>)</div><div class="line">&#125;</div><div class="line">draw1();</div></pre></td></tr></table></figure></p>]]></content>
      
      
        <tags>
            
            <tag> html5 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>BOM</title>
      <link href="/2016/06/30/window%E5%92%8Cdocument/"/>
      <url>/2016/06/30/window%E5%92%8Cdocument/</url>
      <content type="html"><![CDATA[<h2 id="BOM浏览器对象模型"><a href="#BOM浏览器对象模型" class="headerlink" title="BOM浏览器对象模型"></a>BOM浏览器对象模型</h2><p>在JavaScript中对象之间并不是独立存在的，对象与对象之间有着层次关系。浏览器对象模型就是用于描述这种对象与对象之间层次关系的模型，该对象模型提供了独立于内容的、可以与浏览器窗口进行互动的对象结构。BOM由多个对象组成，其中代表浏览器窗口的Window对象是BOM的顶层对象，其他对象都是该对象的子对象。在Window对象之下有下述几个子对象。</p><a id="more"></a><h2 id="Document对象"><a href="#Document对象" class="headerlink" title="Document对象"></a>Document对象</h2><p>该对象代表浏览器窗口中所加载的文档。使用Document对象可以操作文档中的内容。在整个BOM中，只有Document对象是与HTML文档的内容相关的。</p><p>Frames数组：该数组代表浏览器窗口中的框架。HTML中允许将一个浏览器窗口分为多个框架，每个框架中可以加载一个HTML文档。在这种框架页中，每一个框架都是Frames数组中的一个元素。而Frames数组中的每一个元素都是一个Window对象。</p><h2 id="History对象"><a href="#History对象" class="headerlink" title="History对象"></a>History对象</h2><p>该对象代表当前浏览器窗口的浏览历史。通过该对象可以将当前浏览器窗口中的文档前进或后退到某一个已经访问过的URL（统一资源定位符）。</p><h2 id="Location对象"><a href="#Location对象" class="headerlink" title="Location对象"></a>Location对象</h2><p>该对象代表当前文档的URL。URL分为几个部分，如协议部分、主机部分、端口部分等。使用Location对象可以分别获得这些部分，并且可以通过修改这些部分的值来加载一个新文档。</p><h2 id="Navigator对象"><a href="#Navigator对象" class="headerlink" title="Navigator对象"></a>Navigator对象</h2><p>该对象是浏览器对象，代表了浏览器的信息。该对象与Window对象不同，Window对象可以用于控制浏览器窗口的一些属性，如浏览器窗口大小、位置等。而Navigator对象包含的是浏览器的信息，如浏览器的名称、版本号等。</p><h2 id="Screen对象"><a href="#Screen对象" class="headerlink" title="Screen对象"></a>Screen对象</h2><p>该对象代表当前显示器的信息。使用Screen对象可以获得用户显示器的分辨率、可用颜色数量等信息。</p><p>Document对象代表HTML文档，而HTML文档中包括了有很多元素，BOM也将这些元素看成了不同的对象。从图12-2中可以看出，Document对象还有下述几个子对象。</p><h2 id="Anchors数组"><a href="#Anchors数组" class="headerlink" title="Anchors数组"></a>Anchors数组</h2><p>该数组代表了文档中的所有锚。数组中的每一个元素都是一个锚对象。每一个锚对象都对应着HTML文档中的一个包含name属性的<a>标签，通过锚对象可以获得锚的命名，以及超链接中的文字。</a></p><h2 id="Applets数组"><a href="#Applets数组" class="headerlink" title="Applets数组"></a>Applets数组</h2><p>该数组代表了嵌在网页中的所有小程序。数组中的每一个元素都是一个Applet对象，通过Applet对象可以获得Java小程序的公有字段。</p><h2 id="Embeds数组"><a href="#Embeds数组" class="headerlink" title="Embeds数组"></a>Embeds数组</h2><p>与Applets类似，但建议使用Embeds数组。</p><h2 id="Forms数组"><a href="#Forms数组" class="headerlink" title="Forms数组"></a>Forms数组</h2><p>该数组代表文档中</p><p>的所有表单。数组中的每一个元素都是一个Form对象。每一个Form对象都对应着HTML文档中的一个<form>标签。通过Form对象可以获得表单中的各种信息，也可以提交或重置表单。由于表单中还包括了很多表单元素，因此，Form对象的子对象还可以对这些表单元素进行引用，以完成更具体的应用。</form></p><h2 id="Images数组"><a href="#Images数组" class="headerlink" title="Images数组"></a>Images数组</h2><p>该数组代表文档中的所有图片。数组中的每一个元素都是一个Image对象。每一个Image对象都对应着HTML文档中的一个<img>标签。通过Image对象可以获得图片的各种信息。</p><h2 id="Links数组"><a href="#Links数组" class="headerlink" title="Links数组"></a>Links数组</h2><p>该数组代表文档中的所有超链接。数组中的每一个元素都是一个Link对象。每一个Link对象都对应着HTML文档中的一个包含href属性的<a>标签，通过Link对象可以获得超链接中URL的各部分信息。</a></p><h2 id="Location对象-1"><a href="#Location对象-1" class="headerlink" title="Location对象"></a>Location对象</h2><p>该对象与Window对象中的Location对象完全相同。由于该对象与HTML文档并没有太大关系，因此，该对象是反对使用的对象，建议使用Window对象的Location子对象。</p><p>BOM并不是W3C中的标准，因此，不同的浏览器所支持的BOM中的对象、对象的属性和方法都有可能不同。从图12-2中可以看出，Document对象下有很多子对象，因此Document对象是一个十分重要的对象。事实上，大多数浏览器都支持Document对象。在W3C正式定义DOM之前，BOM中的Document分支就已经被众多浏览器支持。DOM被正式定义之后，分为了三个层次，分别为1级DOM（DOM Level 1）、2级DOM（DOM Level 2）和3级DOM（DOM Level 3）。而BOM中的Document分支被称为0级DOM（DOM Level 0），因为该分支定义了文档功能的基本功能。</p>]]></content>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>HTTP事务</title>
      <link href="/2016/05/02/http%E4%BA%8B%E5%8A%A1+ajax/"/>
      <url>/2016/05/02/http%E4%BA%8B%E5%8A%A1+ajax/</url>
      <content type="html"><![CDATA[<h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><ul><li>request 请求阶段:客户端向服务器发送请求</li><li>response响应阶段:服务器把数据返回给客户端</li></ul><p>客户端和服务器端进行内容的传输,这个过程是由传输协议来完成的–&gt;&gt;http</p><a id="more"></a><h3 id="HTTP报文"><a href="#HTTP报文" class="headerlink" title="HTTP报文"></a>HTTP报文</h3><p>客户端和服务器端传输的内容统称为HTTP报文,报文中详细的内容在谷歌控制台中的NetWork里可以详细的看到</p><ul><li><p>起始行:http报文第一行,在请求报文中用来说明做些什么,在响应报文中说明出现了什么情况</p><ul><li>请求起始行</li><li>响应起始行</li></ul></li><li><p>header:首部</p><ul><li><p>request headers 请求头,客户端设置,服务器获取,一般在真实的项目中我们会把一些内容放在请求头里面传给服务器,例如:客户端可以把一些cookie的信息传给服务器;</p><ul><li><p>设置请求头之前必须保证已经执行OPEN了</p></li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//编码和解码格式:如果想用汉字,就需要相应的客户端编码和服务器解码</div><div class="line">//1.escape/unescape:客户端对中文或者是特殊字符进行编码,服务器进行解码,但是一般不用,因为只有node环境才支持,</div><div class="line">//encodeURI/decodeURI:按照UNICODE编码解码,只对汉字进行编码/解码</div><div class="line">//3.encodeURIComponent/decodeURIComponent:可以把特殊字符和汉字进行编码/解码</div></pre></td></tr></table></figure></li></ul></li><li><p>response headers 响应头,服务器设置,客户端获取,比如我们之前写的返回数据的类型,加在响应头中,获取服务器的时间,这个事件就是响应头中的时间;</p></li></ul></li><li><p>主体</p><ul><li>请求主体:客户端设置,服务器获取,一般把客户端向服务器传输的数据都放在请求主体里面 send(数据)</li><li>响应主体:服务器返回给客户端的数据都写在响应主体中,response.end(这里面的东西就是响应主体)</li></ul></li></ul><h2 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h2><h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么?"></a>是什么?</h3><p><strong>AJAX是 Async(异步) Javescript And XML的缩写</strong>,是客户端js中的方法,用来向服务器端发送请求(还可以传递给服务器端数据 ),然后把服务器端返回的内容获取到(ajax一般是运行在客户端的浏览器中的);</p><p>xml:可扩展的标记语言(在xml文件中使用的标签都是自己扩展的)–&gt;&gt;利用自己扩展的有规则的标记来存储相关的数据</p><p><strong>异步</strong>:客户端和服务器数据交互不需要整个页面刷新,只需要将操作的这一部分更新一下,这就叫做局部刷新;</p><ul><li>AJAX一般都是用来请求页面的部分数据,再将获取出来的数据绑定到页面的指定位置</li></ul><h3 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h3><p>四步:</p><ul><li>1)创建一个ajax的异步对象<code>var xhr=new XMLHHTTPRequest</code>(这种方式不兼容IE6及更低版本的浏览器,需要做兼容处理)</li><li><p>2)打开一个URL地址并请求(发送请求之前的配置)</p><ul><li><code>open([请求方式],[API接口],[设置同步异步],[user name],[user pass])</code></li><li><p>[请求方式]:</p><ul><li>get系列:get/delete/head</li><li>post系列:post/put</li></ul></li><li>[user name]:用户名</li><li>[user pass]:用户密码</li></ul></li></ul><blockquote><p>有些服务器为了安全考虑,只允许部分人可以访问,就只给部分人分配权限,访问的时候需要提供安全密钥,一般的服务器不需要这么麻烦,匿名访问即可,所以只需要传前三个参数即可;</p></blockquote><ul><li><p>3)监听不同的状态进行不同的业务操作   onreadystatechange</p><ul><li><p>xhr.readyState:Ajax状态码,可以代表当前ajax处理的进度;</p><ul><li>0:unsend  未发送,刚开始创建一个AJAX的实例,<code>var xhr=new XMLHHTTPRequest</code>;(请求阶段)</li><li>1:open  url地址已经打开(发送前的参数配置已经完成),第二步open(“get”,url,true);(请求阶段)</li><li>2:headers_received  客户端已经接收响应头(响应阶段,此时的响应头里包含了发送响应头的服务器时间)</li><li>3:loading  服务器返回的响应主体正在传输(响应阶段)</li><li>4:done  服务器返回的响应主体已经被客户端接收;(响应阶段)</li></ul></li><li><p>xhr.status  HTTP网络状态码   http响应报文返回时都会携带一个状态码,通过这个状态码可以知道HTTP事务是否成功,以及失败的原因</p><ul><li>[2开头]:只要是2开头的就代表成功,比如:200:ok</li><li>[3开头]:也代表成功,只不过这个过程经过了特殊处理<ul><li>301:Moved Permanently 在新版的HTTP协议中代表永久重定向,比如访问<a href="http://www.360buy.com默认会跳转到京东" target="_blank" rel="external">http://www.360buy.com默认会跳转到京东</a> <a href="http://www.jd.com" target="_blank" rel="external">http://www.jd.com</a></li><li>302:Moved temporarily  在新版的HTTP协议中代表临时转移(也叫临时重定向) –&gt;服务器的负载均衡</li><li>304:Not Modified()获取的是缓存中的数据(网站性能优化的重要手段,我们一般将一些不怎么变的静态资源js/css/img等 做成304缓存 以后直接从缓存中拿就可以了  )</li></ul></li><li>[4开头]  代表错误,而且一般都是客户端的错误<ul><li>400: Bad Request 请求参数出错了</li><li>401:Unauthorized  无访问权限  </li><li>403:请求接收到了,但是没有返回正常的结果,而且没有原因</li><li>404:Not Found 请求地址不存在 </li><li>413:客户端传给服务器的内容超过了服务器愿意接收的范围</li></ul></li><li>[5开头]  代表服务器错误<ul><li>500:  Iternal Server Error 服务器的未知错误</li><li>503: Server UNavailable服务器超负荷</li></ul></li></ul></li><li>xhr.response: 获取响应主体(一般不用)</li><li>xhr.responseText:获取响应主体的内容(是text字符串格式的)</li><li>xhr.responseXML:获取响应主体的内容,但是是XML格式的</li><li>xhr.getResponseHeader:获取响应头</li><li>xhr.getAllResponseHeaders:获取所有的响应头</li><li>xhr.timeout: 设置请求的超时时间,比如设置的是3s,超过3s就算请求失败,并且如果请求超时就会触发一个 ontimeout事件</li><li>xhr.abort():中断当前的AJAX请求,而且 一旦中断请求就会触发onabort事件</li><li>xhr.setrRequestHeader([属性名],[属性值]):设置请求头信息</li></ul></li><li>4)发送send():AJAX这件事是从send开始的之前的步骤都是在做准备工作,当我们的xhr.readyState==4的时候结束</li></ul><h3 id="GET和POST的区别"><a href="#GET和POST的区别" class="headerlink" title="GET和POST的区别"></a>GET和POST的区别</h3><ul><li>get系列与post系列的不同<ul><li>1) 传参数的方式不同:get方式是通过问号传参(url+?+参数),    post: xhr.send(给后台发送的数据,是字符串);</li><li>2) get方式容易出现缓存(可以通过加一个时间戳来解决缓存问题),    出现缓存的原因是GET是通过url上问号拼接参数的形式给服务器传参数的,如果当前传的参数跟上一次的一样了,浏览器就会走他的记忆功能(缓存),以为你请求的是同一个url,就会把之前返回给你,这样有些需求是不可以的.    比如我想实时获取股票信息,就不能走缓存.   而post不会</li><li>3)参数大小:get方法限制大小,get是将数据直接拼接在url后端query部分,而浏览器对url的长度有限制,所以get有大小限制,post没有大小限制.因为post是将数据放在请求的主体里,而主体是不限制大小的,所以没有大小的限制(但是我们一般不会让他大于100kb);(chrome是8kb  firefox是7kb  ie是2kb)</li><li>4)安全性: get可以看到发送给服务器的数据,因为他是放在url上的, 而post不会被看到,因为post把数据放到主体里了 ,一般有重要的信息都会采用post请求</li><li>5)功能: get主要是用来从服务器拉取数据,而post主要是用来将数据发送到服务器</li></ul></li></ul>]]></content>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>CSS3选择器</title>
      <link href="/2016/04/26/CSS3/"/>
      <url>/2016/04/26/CSS3/</url>
      <content type="html"><![CDATA[<h2 id="1-动态伪类选择器"><a href="#1-动态伪类选择器" class="headerlink" title="1.动态伪类选择器"></a>1.动态伪类选择器</h2><ul><li>a:hover 鼠标放上</li><li>:focus 获取焦点一般用在表单元素上</li><li>a:active 鼠标点一下</li><li>a:visited 链接访问过一般用在锚点</li><li>a:link 链接未被访问过 一般用在锚点</li></ul><a id="more"></a><h2 id="2-UI伪类选择器"><a href="#2-UI伪类选择器" class="headerlink" title="2.UI伪类选择器"></a>2.UI伪类选择器</h2><ul><li>input:disabled(禁用)</li><li>input:enabled(可用)</li><li>input:checked(被选中的)<h2 id="3-结构伪类选择器"><a href="#3-结构伪类选择器" class="headerlink" title="3.结构伪类选择器"></a>3.结构伪类选择器</h2></li><li>div :first-child选择第一个子元素</li><li>div :last-child最后一个子元素</li><li>nth-child(2)<ul><li>nth-child(n) n是整数以1开始</li><li>nth-child(even)所有偶数</li><li>nth-child(odd)所有奇数 </li></ul></li><li>nth-last-child(1)倒着数</li><li>nth-of-type(2)同类型的第几个</li><li>nth-last-of-type倒着数</li><li>first-of-type同类型的第一个</li><li>last-of-type同类型的最后一个</li><li>only:child父级只有他一个孩子</li><li>div:empty没有任何内容的div<h2 id="4-伪元素选择器-也可以用"><a href="#4-伪元素选择器-也可以用" class="headerlink" title="4.伪元素选择器(:也可以用::)"></a>4.伪元素选择器(:也可以用::)</h2></li><li>:after</li><li>:before</li><li>first-line首行</li><li>first-letter首字母</li></ul>]]></content>
      
      
        <tags>
            
            <tag> CSS3 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>静态资源文件请求的处理</title>
      <link href="/2016/01/03/%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6%E8%AF%B7%E6%B1%82%E7%9A%84%E5%A4%84%E7%90%86/"/>
      <url>/2016/01/03/%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6%E8%AF%B7%E6%B1%82%E7%9A%84%E5%A4%84%E7%90%86/</url>
      <content type="html"><![CDATA[<p>带后缀名的都是静态资源文件,请求静态资源–&gt;前端路由</p><a id="more"></a><h3 id="MIME类型"><a href="#MIME类型" class="headerlink" title="MIME类型"></a>MIME类型</h3><p>每一种资源文件都有自己的标识类型</p><ul><li>html–&gt;&gt;text/html</li><li>css–&gt;&gt;text/css</li><li>js–&gt;&gt;text/javascript</li><li>txt–&gt;&gt;text/plain</li><li>json–&gt;application/json</li><li>​</li></ul><p>浏览器会按照代码的MIME类型进行渲染,所以要根据请求文件的后缀名获取当前文件的MIME类型,让服务器按照指定的目录读取文件中的内容或者代码(读取出来的内容都是字符串格式的),返回给客户端的也应当是字符串格式的文件</p><h3 id="重写响应头信息"><a href="#重写响应头信息" class="headerlink" title="重写响应头信息"></a>重写响应头信息</h3><p>告诉浏览器返回的内容是什么养的MIME类型</p><p>response.writeHead(200,{“content-type”:pathname+”;charset=utf-8;”})</p>]]></content>
      
      
        <tags>
            
            <tag> node.js </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>node之buffer</title>
      <link href="/2016/01/02/node%E7%AC%AC%E4%BA%8C%E5%A4%A9/"/>
      <url>/2016/01/02/node%E7%AC%AC%E4%BA%8C%E5%A4%A9/</url>
      <content type="html"><![CDATA[<h2 id="发布订阅模式"><a href="#发布订阅模式" class="headerlink" title="发布订阅模式"></a>发布订阅模式</h2><ul><li>on  emit</li><li>订阅 维护关系的 ,一对多的关系</li><li>发布 找到一对多的关系,让绑定的事情一次触发</li></ul><blockquote><p>主要依赖的就是回调函数</p></blockquote><a id="more"></a><h2 id="buffer"><a href="#buffer" class="headerlink" title="buffer"></a>buffer</h2><ul><li>buffer代表的是内存</li><li>node为了操作二进制生产出来的一个类型,buffer默认展示成16进制,可以和字符串无条件转换</li><li>2进制,16进制</li><li>字符串在node中只支持utf-8的格式</li><li>一个汉字utf-8有几个字节–&gt;&gt;3个字节</li><li>比字节小的单位  1个字节由8个位组成,</li><li>二进制转10进制: 当前的最大值*二进制(当前第几位-1)累加求和</li></ul>]]></content>
      
      
        <tags>
            
            <tag> node.js </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>node基础二</title>
      <link href="/2016/01/01/%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%92%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E4%BA%A4%E4%BA%92%E6%A8%A1%E5%9E%8B/"/>
      <url>/2016/01/01/%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%92%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E4%BA%A4%E4%BA%92%E6%A8%A1%E5%9E%8B/</url>
      <content type="html"><![CDATA[<p>交互模型图</p><p><img src="/img/前后端交互模型图.png" alt="前后端交互模型图"></p><a id="more"></a><ul><li>客户端:用户自己电脑的浏览器</li><li>服务器端:浏览项目所在的服务器</li><li>服务器的端口号:属于服务器,一台服务器上可以发布很多的项目,而每一个项目都有自己对应的房间或区域,服务器使用端口号来区分具体是哪一个项目(在0-65535之间) <ul><li>一般我们把自己的项目发布到80/443这两个端口下</li></ul></li><li>引擎:每一个浏览器都有自己的引擎,谷歌浏览器是v8引擎(webkit),火狐浏览器是Gecko引擎,Ie是Trident引擎</li><li>谷歌浏览器控制台NetWork这一项,可以看到当前的客户端向服务器端发送的所有的请求以及请求的状态信息等;对于优化非常的重要  </li><li>通过NetWork中观看,我们发现当我第一次把html源代码请求回来的时候,浏览器开始按照自己的引擎渲染,在渲染过程中我们还会出现重新向服务器请求css/js/img…,每一次请求步骤和请求html时的步骤是一样的,如果请求的资源次数过多,页面打开的速度和渲染的速度就会变慢,所以我们以后再页面优化的方法中,首先要做的就是<strong>减少资源请求 </strong>(减少http请求),<ul><li>css合并成一个 或者如果css不是很多的话我们采用内嵌式css</li><li>js合并成一个 或者采用内嵌式</li><li>图片合并(雪碧图技术/css sprite)或者图片延迟加载</li><li>ajax请求和资源文件的请求原理是一样的</li></ul></li></ul><h2 id="URI-URL-URN"><a href="#URI-URL-URN" class="headerlink" title="URI/URL/URN"></a>URI/URL/URN</h2><p>URI=URL+URN统一资源标识符(统一资源信息)</p><h2 id="url-统一资源定位符"><a href="#url-统一资源定位符" class="headerlink" title="url 统一资源定位符"></a>url 统一资源定位符</h2><p><a href="http://v.qq.com:80/index.html?name=zhufeng&amp;age=7#bbs" target="_blank" rel="external">http://v.qq.com:80/index.html?name=zhufeng&amp;age=7#bbs</a></p><ul><li>http:传输协议  –&gt;客户端给服务器端的内容和服务器端传递给客户端的内容都是通过http传输协议进行传输的(我们可以把http理解为快递小哥 )</li><li>v.qq.com:域名</li><li>:80  端口号</li><li>index.html:请求资源文件名–&gt;告诉服务器我需要请求的资源文件是谁</li><li>?name=zhufeng&amp;age=7:URl问号传参–&gt;客户端传递给服务器端的内容(客户端可以把一些值传递给服务器端,服务器依然可以把一些内容传递给客户端)</li><li>#bbs URL的hash(哈希值,锚点定位)</li></ul><h2 id="传输协议"><a href="#传输协议" class="headerlink" title="传输协议"></a>传输协议</h2><ul><li><p>http:超文本传输协议,除了传输文本外还可以传输其他的东西,例如:xml等</p></li><li><p>https:更加安全的http</p></li><li><p>ftp:文件传输协议(应用于把项目源文件传递到服务器上)</p></li><li><p>在不指定服务器端口的情况下,每一种协议会有一个默认找的端口地址</p><ul><li>-&gt;http默认会找服务器的80端口</li><li>–&gt;https默认会找服务器的443端口</li><li>–&gt;ftp默认会找服务器的21端口</li></ul></li></ul><h2 id="URN"><a href="#URN" class="headerlink" title="URN"></a>URN</h2><p>统一资源名称</p><h1 id="初识node"><a href="#初识node" class="headerlink" title="初识node"></a>初识node</h1><h2 id="node是什么"><a href="#node是什么" class="headerlink" title="node是什么"></a>node是什么</h2><p>我们之前说js是一门运行在客户端(运行在浏览器)的”轻量级”的脚本变成语言,这种说法是错的,–&gt;&gt;js目前不仅仅只能在浏览器中运行,还可以在node中运行</p><ul><li><p>node是衣蛾环境,供js代码执行的环境,我们可以把它等价于浏览器,只不过我们一般会把node这个环境安装到服务器端,这样的话我们就可以在服务器端使用js编写程序了,也就是说js不仅仅是客户端的语言也是服务器端的语言… </p><h2 id="node和浏览器"><a href="#node和浏览器" class="headerlink" title="node和浏览器"></a>node和浏览器</h2></li><li><p>node采用的是谷歌的v8引擎来渲染js的(运行的速度快,稳定,我们编写的js代码不需要考虑兼容,比如JSON.parse()这个方法对ie浏览器有兼容,而node的引擎就一个–&gt;谷歌的v8引擎,所以不需要考虑兼容)</p></li><li>浏览器中的’’全局js对象是window,而node环境下的全局js对象是global</li><li>浏览器是安装在客户端的,为了保护客户端的安全,基本上不可能提供用js对客户电脑磁盘上的文件进行操作的功能; 但是node环境中提供了对象的I/O操作(服务器上文件的操作),我们使用js可以对服务器磁盘下的文件进行增删改查</li><li>node提供给js很多新的方法:http.createServer,fs.writeFileSync,fs.readFileSync…</li><li>node是基于事件驱动的异步编程(我们在node环境下编写的js程序一般都是异步编程程序)</li></ul><h2 id="如何让js代码在node中执行"><a href="#如何让js代码在node中执行" class="headerlink" title="如何让js代码在node中执行"></a>如何让js代码在node中执行</h2><ul><li>利用webstorm嵌入的node机制,直接把编写的js通过右键”run xxx.js”在node环境中执行(不建议使用,因为有些时候我们最新执行的操作会受到之前执行的缓存的影响 )</li><li>在命令窗口中执行 node xxx.js<ul><li>js代码发生改变时要重新执行</li></ul></li><li>在命令窗口中直接输入node–&gt;enter即可在当前的命令窗口中编写js代码进行测试了;(rpel命令操作),让当前任务结束就执行两次ctrl+c</li></ul><h2 id="node模块"><a href="#node模块" class="headerlink" title="node模块"></a>node模块</h2><p>,模块中是在node环境中供js调取使用的方法</p><ul><li>1)<strong>内置模块</strong>(node环境天生就提供的):http(createServer创建服务),fs(writeFileSync,readFileSync…),url…</li><li>2)<strong>自定义模块</strong>(我们自己定义的模块):<ul><li>在,node环境中,我们在当前的项目下创建一个js就是创建一个模块,例如,新建一个a.js,就是创建了一个a模块</li><li>在b模块中获取a模块中的方法<ul><li>1) 将我们要在b模块中使用的a模块中的方法在a模块中暴露出来module.exports={fn:fn}/module.exports.fn=fn,前者是批量导出</li><li>2) var a=require(“./a”);表示导入当前文件夹下的a模块(不要写成”./a.js”现在a表示的是a这个模块)</li></ul></li></ul></li><li>3)<strong>第三方模块</strong>(别人写好的模块我们拿来使用):在node中我们如果需要使用别人的模块,需要使用npm这个命令来进行管理(<a href="https://www.npmjs.com" target="_blank" rel="external">https://www.npmjs.com</a>)<ul><li>安装:npm install less -g   将less安装到全局</li><li>卸载:npm uninstall less -g   卸载全局中的less模块</li><li>安装成功后在js中通过var less=require(“less”);把刚才安装的第三方模块导入到js中,这样的话我们就可以使用这个模块中提供的方法了less.render…</li></ul></li></ul><h2 id="node模块中的常用方法"><a href="#node模块中的常用方法" class="headerlink" title="node模块中的常用方法"></a>node模块中的常用方法</h2><h3 id="http模块"><a href="#http模块" class="headerlink" title="http模块"></a>http模块</h3><h4 id="http-createServer"><a href="#http-createServer" class="headerlink" title="http.createServer"></a>http.createServer</h4><ul><li>创建一个服务<code>var server=http.createServer(function(request,response){//当客户端向服务器端的当前服务(端口号是80这个服务)发送一个请求,并且当前服务已经成功接收到这个请求后,执行这个回调函数});</code><ul><li>request(请求):这个参数存放的是所有客户端的请求信息,包含客户端通过问号传参的方式传递给服务器的数据内容<ul><li>request.url:存放的是客户端请求的文件资源的目录和名称以及传递给服务器的数据地址(即去掉传输协议,域名/ip地址和端口号的部分)</li></ul></li><li>response(响应):提供了向客户端返回内容和数据的方法<ul><li>response.write()向客户端返回内容</li><li>response.end()告诉服务器响应结束了(必须加,要不然不知道这次请求的响应什么时候结束)</li></ul></li></ul></li><li>为server这个服务去监听一个80端口<code>server.listen(80,function(){//当服务创建成功并且端口号监听成功后执行这个回调函数});</code>    </li><li>服务创建成功后,如何向服务器端发送请求        <ul><li>在浏览器中输入<a href="http://localhost:端口号/(监听的是63342端口,是webstorm给我们生成的服务给创建的一个端口" target="_blank" rel="external">http://localhost:端口号/(监听的是63342端口,是webstorm给我们生成的服务给创建的一个端口</a>)</li><li>在浏览器 中输入本机的ip地址<a href="http://本机的ip地址:端口号/" target="_blank" rel="external">http://本机的ip地址:端口号/</a></li></ul></li></ul><h3 id="url模块"><a href="#url模块" class="headerlink" title="url模块"></a>url模块</h3><h4 id="url-parse"><a href="#url-parse" class="headerlink" title="url.parse()"></a>url.parse()</h4><p>用来解析URL地址的 url.parse(str,true);增加true后,在query中存储的是经过处理解析后的结果:把传递进来的多组数据以键值对的方式进行存储</p><h3 id="fs模块"><a href="#fs模块" class="headerlink" title="fs模块"></a>fs模块</h3><h4 id="fs-readFileSync"><a href="#fs-readFileSync" class="headerlink" title="fs.readFileSync()"></a>fs.readFileSync()</h4><p>fs.readFileSync([path+name],[encode])同步读取指定文件中的内容,(同步读取,文件中的内容读取不完就不执行下面的操作,只有读取出来才会执行后续的操作)</p>]]></content>
      
      
        <tags>
            
            <tag> node.js </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>node基础二</title>
      <link href="/2016/01/01/node%E7%AC%AC%E4%B8%80%E5%A4%A9/"/>
      <url>/2016/01/01/node%E7%AC%AC%E4%B8%80%E5%A4%A9/</url>
      <content type="html"><![CDATA[<h3 id="怎么解决异步问题"><a href="#怎么解决异步问题" class="headerlink" title="怎么解决异步问题?"></a>怎么解决异步问题?</h3><ul><li>callback</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> read=<span class="function">(<span class="params">cb</span>)=&gt;</span>&#123;</div><div class="line">    setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</div><div class="line">        <span class="keyword">let</span> str=<span class="string">"wohenmei"</span>;</div><div class="line">        cb(str);</div><div class="line">    &#125;,<span class="number">2000</span>)</div><div class="line">&#125;</div><div class="line">read(<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(data);</div><div class="line">&#125;);<span class="comment">//解决异步问题,可以输出str</span></div></pre></td></tr></table></figure><a id="more"></a><h3 id="node环境下的js不具有兼容性"><a href="#node环境下的js不具有兼容性" class="headerlink" title="node环境下的js不具有兼容性"></a>node环境下的js不具有兼容性</h3><h3 id="在node中能用异步绝不用同步"><a href="#在node中能用异步绝不用同步" class="headerlink" title="在node中能用异步绝不用同步"></a>在node中能用异步绝不用同步</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">//解决异步问题,将后续的逻辑当做参数传递给这个函数--&gt;&gt;callback;</div><div class="line">//异步永远在同步之后执行,如果同步执行不能完成,异步永远不会触发</div><div class="line">//非阻塞是异步的前置条件</div></pre></td></tr></table></figure><ul><li>单线程    多线程–&gt;&gt;node是基于js(单进程–&gt;&gt;并且单线程)的</li><li>node(底层是c)  单线程  异步  </li><li>js中的多线程(h5)–&gt;&gt;如果想开多线程–&gt;&gt;要开子进程(这个子进程可以有多线程)</li><li>多线程–&gt;&gt;感觉像同一时间干很多事,实际上只是快速的切换上下文</li></ul><h2 id="js中的模块化"><a href="#js中的模块化" class="headerlink" title="js中的模块化"></a>js中的模块化</h2><ul><li>js中实现模块化–&gt;&gt;单例,闭包</li><li>单例,缺点:不能保证一定不冲突,会导致调用过长,require(AMD),seajs(CMD),import,export,不兼容</li><li>没有块级作用域</li></ul><h3 id="node-自带模块化-commonjs规范"><a href="#node-自带模块化-commonjs规范" class="headerlink" title="node 自带模块化 commonjs规范"></a>node 自带模块化 commonjs规范</h3><ul><li>怎么定义一个 模块(每个js都是一个模块,在每个文件外面自动增加一个闭包)</li><li>如何导出一个模块module.exports/exports;</li><li>如何引用一个模块   require();</li></ul><p>exports,module,require, __dirname ,__filename,都是这个文件外层套了一个闭包,闭包中的形参,这五个也是全局变量</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  </div><div class="line">&#125;)(exports,<span class="built_in">module</span>,<span class="built_in">require</span>,__dirname,__filename)</div></pre></td></tr></table></figure><h2 id="模块分类"><a href="#模块分类" class="headerlink" title="模块分类"></a>模块分类</h2><h3 id="文件模块"><a href="#文件模块" class="headerlink" title="文件模块"></a>文件模块</h3><ul><li>暴露的实现原理</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"> (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">   <span class="built_in">module</span>.exports=exports=&#123;&#125;;<span class="comment">//所以不能直接更改exports,用exports=obj的形式导出想要的方法,因为export被重新赋值了,与module.exports的连接断了</span></div><div class="line">    <span class="comment">//this--&gt;&gt;module.exports;</span></div><div class="line">    <span class="keyword">return</span> <span class="built_in">module</span>.exports;</div><div class="line">&#125;)()</div></pre></td></tr></table></figure><ul><li>三种暴露方式(特别注意返回值是module.exports)<ul><li>1)module.exports=sum–&gt;&gt;sum是要暴露出的函数</li><li>2)module. exports.sum=sum</li><li>3)exports.sum=sum</li></ul></li></ul><h3 id="第三方模块"><a href="#第三方模块" class="headerlink" title="第三方模块"></a>第三方模块</h3><ul><li><p>全局安装(只能在命令行下使用) node切换源的工具</p><ul><li><p>npm install nrm -g</p></li><li><p>nrm ls–&gt;&gt;源列表</p><p><img src="/img/nrm.PNG" alt="nrm"></p></li><li><p>nrm test(测试源)</p></li><li><p>nrm use cnpm</p></li></ul></li><li><p>本地安装 (在当前项目下使用)</p><p>npm  init 生成记录所有依赖的package.json,否则会安装到上级目录,名字不能有中文不能有大写,和特殊字符</p><ul><li>开发依赖 只在开发时应用–save-dev(简写–&gt;&gt;-D)</li><li>项目依赖  开发上线都需要–save(简写–&gt;&gt;-S)</li><li>安装 npm install</li><li>卸载npm uninstall 模块的名字</li><li>查看模块版本 npm info vue</li><li>指定版本安装 npm install vue@1.0.0 –save</li></ul></li><li><p>引用</p><ul><li>直接require(模块名称),不需要./或../,在node_modules下查找,当前目录下没有回去上级查找,找到根盘符为止 module.paths 查找的顺序</li></ul></li></ul><h4 id="yarn-需要npm来下载-主流"><a href="#yarn-需要npm来下载-主流" class="headerlink" title="yarn 需要npm来下载(主流)"></a>yarn 需要npm来下载(主流)</h4><ul><li>安装一次即可</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install yarn -g</div></pre></td></tr></table></figure><ul><li>yarn init -y</li><li>本地安装<ul><li>开发依赖yarn add less –dev</li><li>项目依赖   yarn add jquery</li></ul></li><li>删除<ul><li>yarn remove less –dev</li></ul></li></ul><h4 id="安装全部依赖"><a href="#安装全部依赖" class="headerlink" title="安装全部依赖"></a>安装全部依赖</h4><p>yarn install</p><h4 id="发布包-必须得是别人没发过的-包里需要一个package-json文件"><a href="#发布包-必须得是别人没发过的-包里需要一个package-json文件" class="headerlink" title="发布包(必须得是别人没发过的,包里需要一个package.json文件)"></a>发布包(必须得是别人没发过的,包里需要一个package.json文件)</h4><ul><li>需要登录到官方npm上</li><li>注册账号<ul><li>npm assUser</li></ul></li></ul><blockquote><p>npm node package manager 管理node的包(很多js文件)的,安装node自带npm</p></blockquote><h3 id="内置模块-核心模块-–-gt-gt-node自带的"><a href="#内置模块-核心模块-–-gt-gt-node自带的" class="headerlink" title="内置模块(核心模块)–&gt;&gt;node自带的"></a>内置模块(核心模块)–&gt;&gt;node自带的</h3>]]></content>
      
      
        <tags>
            
            <tag> node.js </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>react基础</title>
      <link href="/2015/12/06/react/"/>
      <url>/2015/12/06/react/</url>
      <content type="html"><![CDATA[<p>把react的基础知识先进行一个梳理，还有后续。。。</p><a id="more"></a><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ul><li><p>1.安装create-react-app</p><p>npm install create-react-app -g</p></li><li><p>2.生成项目</p><p>create-react-app xxx</p></li><li><p>3.启动项目</p><p>cd xxx<br>npm start</p></li></ul><h3 id="react的核心概念"><a href="#react的核心概念" class="headerlink" title="react的核心概念"></a>react的核心概念</h3><ul><li>元素(elements)</li><li>组件(components)</li></ul><h3 id="从jsx到页面"><a href="#从jsx到页面" class="headerlink" title="从jsx到页面"></a>从jsx到页面</h3><p><img src="/img/过程图.png" alt="过程图"></p><h3 id="表达式插入"><a href="#表达式插入" class="headerlink" title="表达式插入"></a>表达式插入</h3><p><code>{}</code> 内可以放任何 JavaScript 的代码，包括变量、表达式计算、函数执行等等。 <code>render</code> 会把这些代码返回的内容如实地渲染到页面上，非常的灵活。</p><ul><li>表达式插入不仅仅可以用在标签内部，也可以用在标签的属性上</li><li>注意，直接使用 <code>class</code> 在 React.js 的元素上添加类名如 <code>&lt;div class=“xxx”&gt;</code> 这种方式是不合法的。因为 <code>class</code> 是 JavaScript 的关键字，所以 React.js 中定义了一种新的方式：<code>className</code> 来帮助我们给元素添加类名。</li><li>还有一个特例就是 <code>for</code> 属性，例如 <code>&lt;label for=&#39;male&#39;&gt;Male&lt;/label&gt;</code>，因为 <code>for</code> 也是 JavaScript 的关键字，所以在 JSX 用 <code>htmlFor</code> 替代，即 <code>&lt;label htmlFor=&#39;male&#39;&gt;Male&lt;/label&gt;</code>。而其他的 HTML 属性例如 <code>style</code> 、<code>data-*</code> 等就可以像普通的 HTML 属性那样直接添加上去。</li></ul><h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><ul><li><em>自定义的组件都必须要用大写字母开头，普通的 HTML 标签都用小写字母开头</em>。</li><li>组件可以和组件组合在一起，组件内部可以使用别的组件。就像普通的 HTML 标签一样使用就可以。这样的组合嵌套，最后构成一个所谓的组件树</li></ul><h3 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h3><p>在 React.js 不需要手动调用浏览器原生的 <code>addEventListener</code> 进行事件监听。React.js 帮我们封装好了一系列的 <code>on*</code> 的属性，当你需要为某个元素监听某个事件的时候，只需要简单地给它加上 <code>on*</code> 就可以了。而且你不需要考虑不同浏览器兼容性的问题，React.js 都帮我们封装好这些细节了。</p><ul><li>没有经过特殊处理的话，<em>这些 on\</em> 的事件监听只能用在普通的 HTML 的标签上，而不能用在组件标签上*。也就是说，<code>&lt;Header onClick={…} /&gt;</code> 这样的写法不会有什么效果的。</li></ul><h4 id="事件中的this"><a href="#事件中的this" class="headerlink" title="事件中的this"></a>事件中的this</h4><p>React.js 调用你所传给它的方法的时候，并不是通过对象方法的方式调用（<code>this.handleClickOnTitle</code>），而是直接通过函数调用 （<code>handleClickOnTitle</code>），所以事件监听函数内并不能通过 <code>this</code> 获取到实例。</p><h4 id="event对象"><a href="#event对象" class="headerlink" title="event对象"></a>event对象</h4><p>和普通浏览器一样，事件监听函数会被自动传入一个 <code>event</code> 对象，这个对象和普通的浏览器 <code>event</code> 对象所包含的方法和属性都基本一致。不同的是 React.js 中的 <code>event</code> 对象并不是浏览器提供的，而是<strong>它自己内部所构建的</strong>。</p><ul><li>React.js 将浏览器原生的 <code>event</code> 对象封装了一下，对外提供统一的 API 和属性，这样你<strong>不用考虑不同浏览器的兼容性问题</strong></li></ul><h3 id="state"><a href="#state" class="headerlink" title="state"></a>state</h3><h4 id="setState"><a href="#setState" class="headerlink" title="setState"></a>setState</h4><ul><li>接受对象参数<ul><li><code>setState</code> 方法由父类 <code>Component</code> 所提供。<em>当我们调用这个函数的时候，React.js 会更新组件的状态 state ，并且重新调用 render 方法(ReactDOM.render)，然后再把 render 方法所渲染的最新的内容显示到页面上</em>。</li><li>传入一个对象的时候，这个对象表示该组件的新状态。但你只需要传入需要更新的部分就可以了，而不需要传入整个对象。</li></ul></li></ul><blockquote><p>注意，当我们要改变组件的状态的时候，不能直接用 <code>this.state = xxx</code> 这种方式来修改，如果这样做 React.js 就没办法知道你修改了组件的状态，它也就没有办法更新页面。所以，一定要使用 React.js 提供的 <code>setState</code> 方法，<em>它接受一个对象或者函数作为参数</em>。</p></blockquote><ul><li>接收函数参数<ul><li>这里还有要注意的是，当你调用 <code>setState</code> 的时候，<em>React.js 并不会马上修改 state</em>。而是把这个对象放到一个更新队列里面，稍后才会从队列当中把新的状态提取出来合并到 <code>state</code> 当中，然后再触发组件更新。</li><li>当传入的参数是一个函数时:  React.js 会把上一个 <code>setState</code> 的结果传入这个函数，你就可以使用该结果进行运算、操作，然后返回一个对象作为更新 <code>state</code> 的对象,这样就可以达到上述的<em>利用上一次 setState 结果进行运算</em>的效果。</li></ul></li><li>state合并<ul><li>在 React.js 内部会把 JavaScript 事件循环中的消息队列的同一个消息中的 <code>setState</code> 都进行合并以后再重新渲染组件,所以,在使用 React.js 的时候，并不需要担心多次进行 <code>setState</code> 会带来性能问题。</li></ul></li></ul><h3 id="props"><a href="#props" class="headerlink" title="props"></a>props</h3><h4 id="props不可变"><a href="#props不可变" class="headerlink" title="props不可变"></a>props不可变</h4><ul><li><code>props</code> 一旦传入进来就不能改变<ul><li>你不能改变一个组件被渲染的时候传进来的 <code>props</code>。React.js 希望一个组件在输入确定的 <code>props</code> 的时候，能够输出确定的 UI 显示形态。如果 <code>props</code> 渲染过程中可以被修改，那么就会导致这个组件显示形态和行为变得不可预测，这样会可能会给组件使用者带来困惑。</li></ul></li><li>但这并不意味着由 <code>props</code> 决定的显示形态不能被修改。组件的使用者可以<em>主动地通过重新渲染的方式</em>把新的 <code>props</code> 传入组件当中，这样这个组件中由 <code>props</code> 决定的显示形态也会得到相应的改变。</li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结:"></a>总结:</h4><ul><li>1.为了使得组件的可定制性更强，在使用组件的时候，可以在标签上加属性来传入配置参数</li><li>2.组件可以在内部通过 <code>this.props</code> 获取到配置参数，组件可以根据 <code>props</code> 的不同来确定自己的显示形态，达到可配置的效果。</li><li>3.可以通过给组件添加类属性 <code>defaultProps</code> 来配置默认参数。</li><li>4.<code>props</code> 一旦传入，你就不可以在组件内部对它进行修改。但是你可以通过父组件主动重新渲染的方式来传入新的 <code>props</code>，从而达到更新的效果。</li></ul><blockquote><p>警告:你们安装一个新模块之后，将不再能执行脚本。需要重新安装脚本</p><p>需要安装一下这个 :  npm install react-scripts -S</p></blockquote><h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><p><a href="http://www.css88.com/react/" target="_blank" rel="external">http://www.css88.com/react/</a><br><a href="http://www.redux.org.cn/" target="_blank" rel="external">http://www.redux.org.cn/</a><br><a href="https://reacttraining.cn/" target="_blank" rel="external">https://reacttraining.cn/</a><br><a href="https://scriptoj.com" target="_blank" rel="external">https://scriptoj.com</a> </p>]]></content>
      
      
        <tags>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>HTML5常用标签</title>
      <link href="/2015/08/10/HTML5%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/"/>
      <url>/2015/08/10/HTML5%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/</url>
      <content type="html"><![CDATA[<p>HTML5 是下一代 HTML 标准。<br>HTML , HTML 4.01的上一个版本诞生于 1999 年。自从那以后，Web 世界已经经历了巨变。<br>HTML5 仍处于完善之中。然而，大部分现代浏览器已经具备了某些 HTML5 支持。</p><p>HTML5和CSS3 是两种不同的文本语言</p><a id="more"></a><h2 id="新特性"><a href="#新特性" class="headerlink" title="新特性"></a>新特性</h2><ul><li>用于绘画的 canvas 元素</li><li>用于媒介回放的 video 和 audio 元素</li><li>html4 用来播放视频使用swf （flash）</li><li>对本地离线存储的更好的支持</li><li>新的特殊内容元素，比如 article、footer、header、nav、section</li><li>新的表单控件，比如 calendar、date、time、email、url、search</li><li>更好的服务开发，更加的利于SEO优化</li></ul><h2 id="新增的语意标签"><a href="#新增的语意标签" class="headerlink" title="新增的语意标签"></a>新增的语意标签</h2><p>article  文章  文章页<br>aside 侧边栏<br>datalist  规定input的各种情况<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">datalist</span> <span class="attr">id</span>=<span class="string">"browsers"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"Internet Explorer"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"Firefox"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"Chrome"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"Opera"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"Safari"</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">datalist</span>&gt;</span></div></pre></td></tr></table></figure></p><p>footer 规定body內或文章內的页脚内容<br>header 规定body內或文章內的页头部分<br>一个页面中可以有多少个header和footer标签？<br>从语义上讲最好就出现一对<br>可以出现多个<br>head可以出现几个？<br>只有一个<br>mark 定义文本 带有标记<br>nav 定义导航（该放什么标签就放什么标签 div.nav）<br>section 章节  ==    div 章节<br>details  标签规定了用户可见的或者隐藏的需求的补充细节。<br>details 标签用来供用户开启关闭的交互式控件。任何形式的内容都能被放在 details 标签里边。<br>details&gt;元素的内容对用户是不可见的，除非设置了 open 属性。<br>summary 标签为 details元素定义一个可见的标题。 当用户点击标题时会显示出详细信息<br>we<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">details</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">summary</span>&gt;</span>Copyright 1999-2011.<span class="tag">&lt;/<span class="name">summary</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span> - by Refsnes Data. All Rights Reserved.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>All content and graphics on this web site are the property of the company Refsnes Data.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">details</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">b</span>&gt;</span>注意：<span class="tag">&lt;/<span class="name">b</span>&gt;</span>目前只有 Chrome 和 Safari 6 支持 summary 标签。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div></pre></td></tr></table></figure></p><p>此外 我们再追加两个标签<br>pre    定义预格式文本 – 所见即所得<br>code  定义计算机代码文本</p><p>一个网站有哪些主题的页面</p><ul><li>首页</li><li>列表页</li><li>专题页<ul><li>列表页</li><li>文章页</li></ul></li><li>文章页</li><li>功能页（搜索、用户信息获取页面、结算页面）【表单】</li></ul>]]></content>
      
      
        <tags>
            
            <tag> html5 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ajax和jsonp</title>
      <link href="/2015/05/20/ajax%E5%88%86%E9%A1%B5,%E8%B7%A8%E5%9F%9F/"/>
      <url>/2015/05/20/ajax%E5%88%86%E9%A1%B5,%E8%B7%A8%E5%9F%9F/</url>
      <content type="html"><![CDATA[<h2 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h2><ul><li>同源<ul><li>当前页面的url: <a href="http://localhost:1234/index.html" target="_blank" rel="external">http://localhost:1234/index.html</a></li><li>获取数据的url: <a href="http://localhost:1234/getUserList" target="_blank" rel="external">http://localhost:1234/getUserList</a> —&gt;&gt;这种情况就可以使用ajax来获取数据</li></ul></li><li>非同源(跨域)<ul><li>当前页面的url: <a href="http://localhost:1234/index.html" target="_blank" rel="external">http://localhost:1234/index.html</a></li><li>获取数据的url: <a href="http://matchweb.sports.qq.com/kbs/hotMatchchList" target="_blank" rel="external">http://matchweb.sports.qq.com/kbs/hotMatchchList</a> —&gt;&gt;这种情况就不可以使用ajax来获取数据</li></ul></li><li><p>判断同源与非同源的三个维度(页面的地址和获取数据的url地址进行比较)</p><ul><li><p>协议</p></li><li><p>域名</p></li><li><p>端口号</p></li></ul></li></ul><blockquote><p>这三者都相同就是同源,有一个不一样就是跨域,跨域不可以使用ajax只有同源才可以用ajax</p></blockquote><a id="more"></a><h3 id="用到跨域请求的情况"><a href="#用到跨域请求的情况" class="headerlink" title="用到跨域请求的情况"></a>用到跨域请求的情况</h3><p>我们在自己的网站上需要展示别人网站上的数据–&gt;&gt;需要在自己服务器上访问获取其他网站服务器的数据,例如</p><ul><li>1)需要展示百度,腾讯,微博等第三方平台的数据</li><li>2)如果项目比较大,访问的人也比较多,一般都会用多台服务器管理,服务器之间的访问就是跨域–&gt;&gt;也就是说只要不是同一个服务器的请求都叫做跨域</li><li>3)二级域名sports.qq.com向一级域名www.qq.com获取数据也是跨域</li></ul><h3 id="跨域请求的方式"><a href="#跨域请求的方式" class="headerlink" title="跨域请求的方式"></a>跨域请求的方式</h3><ul><li>jsonp</li><li>iframe</li><li>postMessage</li><li>document.domain</li><li>crossDomain</li></ul><p>一般最常用的是jsonp</p><h3 id="jsonp"><a href="#jsonp" class="headerlink" title="jsonp"></a>jsonp</h3><h4 id="jsonp和ajax的相同点"><a href="#jsonp和ajax的相同点" class="headerlink" title="jsonp和ajax的相同点"></a>jsonp和ajax的相同点</h4><p>都是客户端向服务器端发送请求:给服务器端传递数据或者从服务器端获取数据的方式;</p><h4 id="与ajax的区别"><a href="#与ajax的区别" class="headerlink" title="与ajax的区别"></a>与ajax的区别</h4><p>ajax属于同源策略</p><p>jsonp属于非同源策略(跨域请求)–&gt;&gt;实现跨域请求的方式有很多,只不过jsonp是最常用的</p><p><strong>script标签</strong>是没有同源和非同源之分的,src中引入的js文件是自己的服务器上的或者别人服务器上的都可以(换句话说我们的script标签可以向其他的服务器发送请求,并且其他服务器也可以接收到请求,把你需要的内容返回给客户端),其他的标签<strong>link img audio iframe</strong>也都是可以的</p><h4 id="jsonp的原理"><a href="#jsonp的原理" class="headerlink" title="jsonp的原理"></a>jsonp的原理</h4><p>利用script标签不存在跨域限制,我们把需要的请求数据的地址赋给src属性,这样就可以从别人服务器上获取数据,这样还不够,还需要在js中将浏览器获取到的数据得到,进行后续的操作</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&lt;script&gt;</div><div class="line">    var ss=null;</div><div class="line">    function ff(result) &#123;</div><div class="line">        ss=result;</div><div class="line">        console.log(ss);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&lt;/script&gt;</div><div class="line">&lt;script type="text/javascript" src="http://matchweb.sports.qq.com/kbs/hotMatchList?callback=ff"&gt;&lt;/script&gt;&lt;!--这里获取到数据后会直接给ff传值并让ff自动执行--&gt;</div><div class="line">&lt;script&gt;</div><div class="line">    console.log(ss);//获取的数据已经被存储在ss这个变量中了;</div><div class="line">&lt;/script&gt;</div><div class="line">//腾讯服务器接受到请求,去查找参数callback的值,比如:我们这里传的ff,然后进行解析,赋值'ff(&#123;"name":"aa","age":"12"&#125;)'然后把字符串返回给客户端,客户端让ff执行就可以了</div></pre></td></tr></table></figure><blockquote><p>jsonp请求是get的请求方式   jQ中的jsonp请求：JQ会默认给url后面追加一个变量来清缓存,并且JQ处理jsonp请求的时候,会默认帮我们在请求地址后面创建一个函数  例如:callback=jQuery3210044305935482184644_1498364421862</p></blockquote>]]></content>
      
      
        <tags>
            
            <tag> 跨域 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>html+css笔记之六</title>
      <link href="/2015/04/28/html+css%E7%AC%AC%E5%85%AD%E5%A4%A9%E7%AC%94%E8%AE%B0/"/>
      <url>/2015/04/28/html+css%E7%AC%AC%E5%85%AD%E5%A4%A9%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h2 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h2><h3 id="css的引入方式"><a href="#css的引入方式" class="headerlink" title="css的引入方式"></a>css的引入方式</h3><ul><li>行内式 将css属性通过style这个标签属性直接写在标签中</li><li>内嵌式 将css属性写在style元素内，一般放在head元素内</li><li>外联式 将css、属性写在css文件中，通过link元素将css、文件引入到html中，一般这个元素写在head元素内</li><li>导入式 将css属性写再css文件中，通过@import url（“”）/import“url”语句将css文件导入到html文件内</li><li>@import 必须写在style元素内或者css文件内</li><li>@import必须写到所在文件的第一行<a id="more"></a></li></ul><h3 id="css选择器"><a href="#css选择器" class="headerlink" title="css选择器"></a>css选择器</h3><p>语法：选择器{声明；声明；}每一个声明后面必须跟着分号</p><ul><li>标签选择器 权重1 直接将标签名当选择器</li><li>类选择器 权重10 将标签属性class的属性值当做选择器，选择器前面要加一个“.”</li><li>id选择器 权重100 将标签属性id的属性值当选择器，选择器前面要加一个井号</li><li>通配符选择器*{} 选择当前文档下的所有元素 权重0&lt;x&lt;1</li><li>分组选择器 权重分开计算 将不同的选择器有逗号隔开，将同样的css属性一起给到不同的html元素</li><li><p>交集选择器 所有选择器之和 两个选择器紧挨在一起</p><ul><li>标签选择器和其他选择器组合的时候，标签选择器要放在前面</li></ul><p>​       div.className{}    .className1.className2{}</p><ul><li>组成这个选择器的两个属性或标签必须是同一个html元素的属性</li></ul></li><li><p>后代选择器 权重 所有选择器之和 父代空格子代{}</p><ul><li>父代和后代不一定是相邻的，只要符合后代关系就可以。</li></ul></li><li><p>子代选择器 权重 所有选择器之和 父级选择器&gt; 子代选择器{}</p><ul><li><strong>两个选择器在从属关系上是相邻的，而不是位置上的</strong></li></ul></li><li><p>相邻兄弟选择器 权重 所有选择器之和 哥哥选择器+相邻弟弟选择器{}</p><ul><li>只能选择第一个弟弟元素</li></ul></li><li><p>属性选择器 权重10 将元素的标签属性名和属性值当做选择器，必须写在[中]</p><ul><li>[属性名]{}</li><li>[属性名=属性值]{}</li></ul></li><li>伪类选择器  权重 10  指元素的一个状态，点击 ，经过。。。  基本选择器：伪类{}  例： .box:hover{}</li><li>伪元素 before after 基本选择器：div:before{display：；content：“”；} content的引号不能少，里面可以没有内容 </li></ul><h3 id="display"><a href="#display" class="headerlink" title="display"></a>display</h3><h4 id="block-块级元素"><a href="#block-块级元素" class="headerlink" title="block 块级元素"></a>block 块级元素</h4><p>遵循的浏览器渲染模式<strong>BFC</strong></p><ul><li>独占一行</li><li>子集元素默认会在父级元素的左上角，平级元素会向下排布</li><li>在不设置宽度的时候，宽度是父级元素内容的宽度，高度是本身内容的高度</li><li>可以直接设置盒子模型的所有属性</li><li>可以嵌套所有的属性<ul><li>p dt h1-h6不能嵌套其他的块级元素<h4 id="inline-行内元素"><a href="#inline-行内元素" class="headerlink" title="inline 行内元素"></a>inline 行内元素</h4>遵循的浏览器渲染模式IFC</li></ul></li><li>都会在一行显示,从左到右,到达父级盒子最大宽度后自动折行</li><li>宽度不能设置,宽度和高度是由本身的内容撑起来的</li><li>可以设置border,padding的左右值和margin的左右值</li><li>行内元素不能嵌套块级元素<ul><li>a元素必要的时候可以嵌套其他块级元素(整个模块添加超链接的时候,才可以用)</li></ul></li><li>会受到内容长度的影响,出现基线对齐(上下对齐/垂直对齐)将对齐方式改变为盒子顶部对齐</li><li>在编辑代码的时候，元素之间有空格或回车的时候，在页面显示时，两个盒子之间有间隙<h4 id="inline-block-行内块级元素"><a href="#inline-block-行内块级元素" class="headerlink" title="inline-block 行内块级元素"></a>inline-block 行内块级元素</h4></li><li>都会在一行显示,从左到右,到达父级盒子最大宽度后自动折行</li><li>不设置宽高的时候,宽高有内容 决定</li><li>直接设置宽度和高度,margin和padding</li><li>编辑代码的时候,元素之间有空格或回车的时候,在页面显示时,两个盒子之间有间隙(用font-size:0清除)</li></ul><p>总结:<br>常用的块级元素:<br>div ul ol li p h1-h6 dl dt dd table tr thead tbody tfoot form<br>常用的行内元素:<br>span a em i b strong sup sub u img<br>(img可以直接设置宽高,但是不独占一行)</p><h2 id="浮动"><a href="#浮动" class="headerlink" title="浮动"></a>浮动</h2><ul><li><p>left 左浮动 从第一个元素开始，在父级元素内，从左向右排列，到达父级元素的最大宽度时,会自动折行</p></li><li><p>right 有浮动从第一个元素开始，在父级元素内，从右向左排列，到达父级元素的最大宽度时,会自动折行</p></li><li><p>none 去除浮动 将浮动元素的浮动属性除去</p></li></ul><p>文档流：行内元素和块级元素默认的渲染模式</p><p>  特点:</p><ul><li><p>脱离文档流(父级元素找不到子级元素),相当于来到了第二层级,平行于基本的文档流</p></li><li><p>所有元素都可以设置这个属性a  img div li ul。。。</p></li><li><p>浮动元素可以直接设置盒子模型的所有属性</p></li><li><p>浮动元素不设置宽高,宽高是<strong>本身内容的大小</strong></p></li><li><p>行内元素、行内块级元素和文字会围绕着浮动元素排列</p><blockquote><p>有浮动属性的元素,排列方式听浮动的,没有浮动属性的元素,听display的</p></blockquote></li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">div&#123;</div><div class="line">display:inline-block;</div><div class="line">float:right; 浮动生效</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>浮动带来的影响:父级元素找不到浮动的子级元素,所以一般浮动元素的父级元素如果不设置高度的时候,它的高度就是0,</p><h3 id="清除浮动的方法"><a href="#清除浮动的方法" class="headerlink" title="清除浮动的方法"></a>清除浮动的方法</h3><h4 id="给父级元素高度"><a href="#给父级元素高度" class="headerlink" title="给父级元素高度"></a>给父级元素高度</h4><p>不管内容是什么,高度都是固定的</p><h4 id="给父级元素设置overflow-hidden属性"><a href="#给父级元素设置overflow-hidden属性" class="headerlink" title="给父级元素设置overflow:hidden属性"></a>给父级元素设置overflow:hidden属性</h4><p>是将元素拉回文本流</p><h4 id="给父级元素设置float属性-父子元素都是浮动就可以相互识别了"><a href="#给父级元素设置float属性-父子元素都是浮动就可以相互识别了" class="headerlink" title="给父级元素设置float属性(父子元素都是浮动就可以相互识别了)"></a>给父级元素设置float属性(父子元素都是浮动就可以相互识别了)</h4><h4 id="clear-both只是用来清除浮动"><a href="#clear-both只是用来清除浮动" class="headerlink" title="clear:both只是用来清除浮动"></a>clear:both只是用来清除浮动</h4><ul><li>带有这个属性的元素必须是块级元素</li><li>带有这个属性的元素必须放在最后一个浮动元素之后</li><li>带有这个属性的元素不能带有float属性<br>利用伪类清除浮动是<strong>工作中最长用的方法</strong><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></div><div class="line">.clear&#123;*zoom:1;&#125;/*兼容低版本浏览器*/</div><div class="line">.clear:after&#123;display:block;content:"";clear:both;&#125;/*兼容高版本浏览器*/</div><div class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"clear"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"><span class="comment">&lt;!--::after--&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div></pre></td></tr></table></figure></li></ul><p>用法:</p><ul><li>1,这个属性被放在最后一个浮动元素的最后面</li><li>2,这个属性依附的元素必须是一个块级元素display:block</li><li>3,这个块级元素不能有float的属性<br>利用伪类清除浮动是工作中最常用的方法</li></ul><h2 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h2><h3 id="相对定位"><a href="#相对定位" class="headerlink" title="相对定位"></a>相对定位</h3><p>特点:</p><ul><li>不脱离文档流</li><li>参照物是本身</li><li>给绝对定位的元素做参照物</li><li>发生位置改变的时候原来的位置还占用</li><li>层级大于文档流内其他元素(会盖在其他元素之上)</li><li>当top和bottom同时设定是,top生效,left和right是left生效</li><li>position:relative和float同时设定时,都生效,先浮动后定位(先脱离文档流)</li></ul><blockquote><p>盒子自己发生位置改变,又不影响其他元素的时候选用相对定位</p></blockquote><h3 id="绝对定位"><a href="#绝对定位" class="headerlink" title="绝对定位"></a>绝对定位</h3><ul><li>脱离文档流</li><li>所有元素默认都会去找参照物的起点位置,互相叠盖在一起</li><li>宽度不设置时,宽度和高度由自身内容决定</li><li>绝对定位的元素如果不设置四个方向的值并且同级之前有其他内容,他会排在这个内容之后</li><li>当绝对定位元素有宽和高的时候,top和bottom同时设置,top生效,left 和right,left生效。</li><li>绝对定位元素设置宽高100%时,继承的宽高是其参照物的宽高</li><li>在不设置参照物时,参照物是body</li><li>可以人为设置参照物<ul><li>需是这个绝对定位元素的父级(可不是紧邻的父级)元素</li><li>参照物元素必须是带有定位属性的元素(可以是相对,绝对,固定)</li><li>父级元素都有定位属性,那么绝对定位元素的参照物是离他最近的那个父级元素</li><li>平级元素不能作为参照物</li></ul></li></ul><h3 id="固定定位"><a href="#固定定位" class="headerlink" title="固定定位"></a>固定定位</h3><ul><li>脱离文档流</li><li>参照物始终是可视窗口</li><li>不设置宽高时,宽高时内容大小</li><li>多用在辅导航,返回头部等位置<blockquote><p><code>&lt;a href=&quot;#top&quot;&gt;top&lt;/a&gt;</code><br>a标签中只写一个# 或者 什么都不写 或者 写#top都可以实现回到顶部的特点</p></blockquote></li></ul><h3 id="去掉定位属性position-static"><a href="#去掉定位属性position-static" class="headerlink" title="去掉定位属性position: static"></a>去掉定位属性position: static</h3><h3 id="z-index改变定位元素的层级关系"><a href="#z-index改变定位元素的层级关系" class="headerlink" title="z-index改变定位元素的层级关系"></a>z-index改变定位元素的层级关系</h3><ul><li>不能改变父子之间的层级关系(正值)</li><li>可以设置负值,跑到所有元素之后</li><li>当父子元素都有z-index值得时候,如果父级元素之间有值,那么子级元素不会出来进行比较</li></ul>]]></content>
      
      
        <tags>
            
            <tag> html，css </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>html+css笔记之五</title>
      <link href="/2015/04/10/html+css%E7%AC%AC%E4%BA%94%E5%A4%A9%E7%AC%94%E8%AE%B0/"/>
      <url>/2015/04/10/html+css%E7%AC%AC%E4%BA%94%E5%A4%A9%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h2 id="块级元素的特点"><a href="#块级元素的特点" class="headerlink" title="块级元素的特点"></a>块级元素的特点</h2><ul><li>独占一行，在所在父级元素内依次向下排列，从左上角开始</li><li>宽度和高度在不设置的情况下，宽度继承父级元素内容的宽，高度由本身内容决定</li><li>可以直接设置盒子模型的所有属性(width，height，padding，border，margin )</li><li>可以嵌套其他元素<h2 id="行内元素和行内块级元素"><a href="#行内元素和行内块级元素" class="headerlink" title="行内元素和行内块级元素"></a>行内元素和行内块级元素</h2></li><li>在一行显示，从左到右，达到父级元素最大宽度时，会自动折行</li><li>在编辑代码时，元素之间有回车或者空格，在页面显示时，盒子和盒子之间会有间隙</li><li>默认是基线对齐</li><li>默认不设置宽度的时候，继承父级元素的100%宽度<a id="more"></a></li></ul><h2 id="行内元素"><a href="#行内元素" class="headerlink" title="行内元素"></a>行内元素</h2><ul><li>宽度和高度不能设置</li><li><strong>可以设置padding和margin的左右值</strong><h2 id="行内块级元素"><a href="#行内块级元素" class="headerlink" title="行内块级元素"></a>行内块级元素</h2></li><li>可以设置盒子模型的所有属性<h2 id="在布局中如何使用css属性将块级元素放到一行排布"><a href="#在布局中如何使用css属性将块级元素放到一行排布" class="headerlink" title="在布局中如何使用css属性将块级元素放到一行排布"></a>在布局中如何使用css属性将块级元素放到一行排布</h2></li><li>float:left/right<ul><li>盒子可以从左向右 或者 从右向左</li></ul></li><li>display：inline/inline-block/table</li><li>inline 盒子不能设置宽度和高度</li><li>inline-block 可以设置宽高但是只能从左到右</li><li>table 可以设置宽高但是只能从左到右<ul><li>给父级元素设置display：table</li><li>给子集元素设置display：table-cell（单元格）<h2 id="background背景"><a href="#background背景" class="headerlink" title="background背景"></a>background背景</h2>背景和内容的关系，<strong>背景永远在内容之后</strong><br>space ：平铺并且适应尺寸大小，图片小于盒子的时候才能使用<br>no-repeat 不平铺<br>repeat-x<br>repeat-y<br>background-size：可以是像素可以是百分比（针对于盒子大小）<br>background-position：center center；让图像的中心点和盒子的中心点对齐<br>background-size：cover（100% auto）<br>background-image: url(“”); –&gt; 引入背景图片<br>background-position: 3px 5px;<br>background-origin: content-box; –&gt; 规定背景图片定位的 <blockquote><p>如何让图片的中心点和盒子的中心重合<br>background-position: center center;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">height: 300px;background-color: yellow;</div><div class="line">background-image: url(&quot;导航头部/images/icon.png&quot;),url(&quot;导航头部/images/logo.png&quot;);</div><div class="line">background-position: top center,right bottom;</div><div class="line">/*ie 678 （低版本浏览器） 不兼容*/</div></pre></td></tr></table></figure></blockquote></li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">background: yellow url(&quot;导航头部/images/icon.png&quot;) no-repeat 10px 20px;</div><div class="line">background-size:100% auto;</div></pre></td></tr></table></figure><h2 id="绝对定位"><a href="#绝对定位" class="headerlink" title="绝对定位"></a>绝对定位</h2><ul><li>想让盒子在父级盒子的哪个位置，就在哪个位置</li><li>脱离文档流（父级盒子找不到这个定位子级盒子的宽度和高度了）</li><li>必须有一个参照物，这个参照物只能是这个定位盒子的父级元素（只要是包含的就可以），父级元素还必须有定位属性</li><li>定位的元素层级高于普通元素</li></ul><blockquote><p>当行内元素或行内块级元素设置line-height不生效的时候，可以将这个元素display属性值设置为block<br>块级元素通过display:inline-block;转化后，ie7不会识别，所以要在display:inline-block;之后添加一个*display:inline;<br><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">display</span>: <span class="selector-tag">inline-block</span>;</div><div class="line">*<span class="selector-tag">display</span><span class="selector-pseudo">:inline</span>;</div></pre></td></tr></table></figure></p><p>第二种解决方式是将这个元素直接设置为float浮动的元素</p><p>在ie7中，如果结构<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></div><div class="line"><span class="selector-tag">b</span>&#123;<span class="attribute">float</span>:right;&#125;</div><div class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>文字 <span class="tag">&lt;<span class="name">b</span>&gt;</span><span class="tag">&lt;/<span class="name">b</span>&gt;</span><span class="tag">&lt;/<span class="name">h3</span>&gt;</span></div><div class="line">b元素会跑到h3元素的下方</div><div class="line">将“文字”用一个元素包起来，将这个元素float:left;即可</div></pre></td></tr></table></figure></p></blockquote>]]></content>
      
      
        <tags>
            
            <tag> html，css </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>同步编程和异步编程</title>
      <link href="/2015/04/10/AJAX%E4%B8%AD%E7%9A%84%E5%90%8C%E6%AD%A5%E7%BC%96%E7%A8%8B%E5%92%8C%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"/>
      <url>/2015/04/10/AJAX%E4%B8%AD%E7%9A%84%E5%90%8C%E6%AD%A5%E7%BC%96%E7%A8%8B%E5%92%8C%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/</url>
      <content type="html"><![CDATA[<h2 id="JS中的同步编程和异步编程"><a href="#JS中的同步编程和异步编程" class="headerlink" title="JS中的同步编程和异步编程"></a>JS中的同步编程和异步编程</h2><p>JS是属于单线程的,我们最好使用异步编程</p><p>js中属于异步编程的有:</p><ul><li>定时器都是异步编程的(定时器的时机就算是设置为零也不是立马执行,而是需要等待一段时间:谷歌5-6ms;ie 10-13) </li><li>时间绑定都是异步编程的</li><li>回调函数也可以理解为异步编程</li><li>在AJAX中可以使用异步编程</li></ul><a id="more"></a><h2 id="JS中的同步编程和异步编程-1"><a href="#JS中的同步编程和异步编程-1" class="headerlink" title="JS中的同步编程和异步编程"></a>JS中的同步编程和异步编程</h2><h3 id="ajax中的同步"><a href="#ajax中的同步" class="headerlink" title="ajax中的同步"></a>ajax中的同步</h3><p>当ajax任务开始后(xhr.send),一直需要到readyState===4 的时候任务才结束,此时才可以处理其他的事情;</p><h3 id="ajax中的异步"><a href="#ajax中的异步" class="headerlink" title="ajax中的异步"></a>ajax中的异步</h3><p>当ajax任务开始后(xhr.send),不需要等到readyState===4 ,依然可以处理其他的任务并且只有当其他的任务完成后,才会去看readyState是否为4了,到达4的时候再去 做一些相关的操作;</p>]]></content>
      
      
        <tags>
            
            <tag> 同步/异步 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>html+css笔记之四</title>
      <link href="/2015/03/27/html+css%E7%AC%AC%E5%9B%9B%E5%A4%A9%E7%AC%94%E8%AE%B0/"/>
      <url>/2015/03/27/html+css%E7%AC%AC%E5%9B%9B%E5%A4%A9%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h2 id="选择器回顾"><a href="#选择器回顾" class="headerlink" title="选择器回顾"></a>选择器回顾</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.div</span> <span class="selector-tag">ul</span> <span class="selector-tag">li</span>&#123;&#125;</div><div class="line">第一步选择这个文档中所有的<span class="selector-tag">li</span></div><div class="line">第二部选择哪些<span class="selector-tag">li</span>是<span class="selector-tag">ul</span>下面的</div><div class="line">第三步选择哪些<span class="selector-tag">li</span>是<span class="selector-tag">ul</span>下面，<span class="selector-tag">ul</span>还是<span class="selector-tag">div</span>下面的</div></pre></td></tr></table></figure><blockquote><p>选择器的组成不要超过三个<br>选择器的查找机制是从右向左</p></blockquote><ul><li>交集选择器</li></ul><p>一个元素具有两个属性，可以将这两个属性做成交集选择器<br><strong>组成交集选择器的两部分，必须属于同一个元素</strong></p><a id="more"></a><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">h1.p1&#123;&#125;  -- &gt;  什么都选择不到</div><div class="line">p.p1&#123;&#125;   p.p2&#123;&#125;  .p1.p2&#123;&#125; p.p3&#123;&#125;</div><div class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"p1 p2 p3"</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div></pre></td></tr></table></figure><ul><li>后代选择器（派生选择器）</li></ul><p>祖籍 子级{}只要存在后代关系即可</p><ul><li>子级选择器</li></ul><p>父级&gt;子级{} 父子两个元素是相邻的</p><h2 id="display"><a href="#display" class="headerlink" title="display"></a>display</h2><p>根据这个属性可以将元素分成不同的类型,也会是显示出不同的状态,例如属性值为block的时候,这个元素会独占一行,如果属性值为inline的时候,所有这个属性值得元素都会在一行显示,属性值为none,元素会在页面上消失<br>所有元素都有天生自带的display属性和属性值,叫做内置属性。</p><h4 id="block块级元素"><a href="#block块级元素" class="headerlink" title="block块级元素"></a>block块级元素</h4><p>特点:</p><ul><li>独占一行</li><li>可以设置盒子模型的所有属性(width,height,border,padding,margin)</li><li>默认宽度是父级元素内容的宽度,高度是本身内容的高度</li><li><p>可以嵌套其他元素</p><ul><li>dt不能嵌套其他块级,可以嵌套行内元素等</li><li>p不能嵌套块级元素,可以嵌套其他行内元素等</li></ul></li><li>永远会在父级盒子左上角开始排布，从上到下<blockquote><p>人为设置的样式要比元素自带的权重高<br>块级元素这些特点，我们将其称作 BFC（block formatting context）块状元素在上下文中的渲染模式（块状元素应该怎么排布）</p></blockquote></li></ul><h4 id="inline行内元素"><a href="#inline行内元素" class="headerlink" title="inline行内元素"></a>inline行内元素</h4><p>特点：</p><ul><li>在一行显示</li><li>不能设置宽度，高度<br>-padding，margin 的上下值设置不生效，左右值生效</li><li>默认宽度高度是本身内容的宽高</li><li>几个行内元素默认的垂直方向对齐方式是基线对齐</li><li>在编辑代码时，如果行内元素之间有回车或空格，那么在页面显示的时候，就会有间隙<ul><li>将font-size设置为0，可以解决这个问题，但是要重新设置其他文本</li></ul></li><li>行内元素不能嵌套块级元素</li></ul><h4 id="vertical-align-改变行内元素和行内块级元素的基线对齐方式"><a href="#vertical-align-改变行内元素和行内块级元素的基线对齐方式" class="headerlink" title="vertical-align 改变行内元素和行内块级元素的基线对齐方式"></a>vertical-align 改变行内元素和行内块级元素的基线对齐方式</h4><table><thead><tr><th>值</th><th>作用</th></tr></thead><tbody><tr><td>top</td><td>所有平级元素，去找最高（高度最高）元素的顶部进行对齐</td></tr><tr><td>bottom</td><td>所有平级元素，去找最高（高度最高）元素的底部进行对齐</td></tr><tr><td>middle</td><td>所有平级元素，去找最高（高度最高）元素的中部进行对齐</td></tr><tr><td>length（数值）</td><td>px %</td></tr></tbody></table><blockquote><p>改变对齐方式的时候，所有元素都要添加这个属性</p></blockquote><h4 id="none-将这个元素在页面上隐藏起来（完全消失）"><a href="#none-将这个元素在页面上隐藏起来（完全消失）" class="headerlink" title="none 将这个元素在页面上隐藏起来（完全消失）"></a>none 将这个元素在页面上隐藏起来（完全消失）</h4><blockquote><p>怎样再显示出来：将none用其他的属性值替换，一般使用block</p></blockquote><h2 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h2><p>每一个元素在html中都是一个盒子，用来装其他的盒子或者是内容</p><p>可以将html页面看作是一个仓库，仓库中从上到下摆了很多的箱子，易碎品（盒子和盒子之间要有距离 内容与盒子之间 盒子本身要有厚度）<br>height：100%指的是继承父级元素”内容”的高度</p><p>父子关系的时候，在设置margin值得时候，一般只设置上和左右，不会设置下和右</p><h4 id="margin-支持负值"><a href="#margin-支持负值" class="headerlink" title="margin  支持负值"></a>margin  支持负值</h4><p>margin-left：-30</p><p>margin-left和margin-top为负值的时候跑出浏览器的部分会被吃掉，不会撑开整个页面。</p><h4 id="margin-top的传递问题"><a href="#margin-top的传递问题" class="headerlink" title="margin-top的传递问题"></a>margin-top的传递问题</h4><p>如果父级元素没有padding-top或border-top的值时候，子元素设置margin-top值，会将这个值传递给父元素</p><p>解决方法</p><ul><li>给父元素一个属性，overflow为hidden（不建议使用）</li><li>将子集元素的margin-top值去掉，改成父级元素的padding-top值</li></ul><h4 id="margin-left-margin-right在ie6中会双倍"><a href="#margin-left-margin-right在ie6中会双倍" class="headerlink" title="margin-left/margin-right在ie6中会双倍"></a>margin-left/margin-right在ie6中会双倍</h4><p>当元素浮动的时候，有左右的外边距，有时候ie6会出现双倍边距的问题。<br>解决方案：</p><ul><li>给这个元素添加overflow：hidden</li><li>写ie6的兼容方式，例如：<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">div</span>&#123;</div><div class="line"><span class="attribute">float</span>:left</div><div class="line">margin-left:<span class="number">10px</span></div><div class="line">_margin-left:<span class="number">5px</span><span class="comment">/*浏览器是ie6的时候，读取这句话*/</span></div><div class="line">css属性为hack</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ul><blockquote><p>！important出现在css里面的时候，这个属性会覆盖掉所有之前设置的样式<br>css hack</p></blockquote><h4 id="overflow-盒子内容多余部分的处理方法"><a href="#overflow-盒子内容多余部分的处理方法" class="headerlink" title="overflow: 盒子内容多余部分的处理方法"></a>overflow: 盒子内容多余部分的处理方法</h4><p>值：hidden 直接隐藏多余的<br>scroll 如果有多余部分出现滚动条，如果没有就不出现<br>auto 不论是否有多余部分，都会出现滚动条</p>]]></content>
      
      
        <tags>
            
            <tag> html，css </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>html+css笔记之三</title>
      <link href="/2015/03/20/html+css%E7%AC%AC%E4%B8%89%E5%A4%A9%E7%AC%94%E8%AE%B0/"/>
      <url>/2015/03/20/html+css%E7%AC%AC%E4%B8%89%E5%A4%A9%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h2 id="CSS层叠样式表回顾"><a href="#CSS层叠样式表回顾" class="headerlink" title="CSS层叠样式表回顾"></a>CSS层叠样式表回顾</h2><p>作用：为html结构层增加样式层，常用的css引入模式为外联式，因为外联式可以加快浏览器加载网页的速度，可以重复使用，可以多个html使用一套html样式表，利于修改。<br>（iframe可以用来引入html文件但是会固定尺寸，是内容无法自适应网页尺寸的变化。）</p><ul><li><p>四种引入方法</p><ul><li>行内式： 格式<code>&lt;标签 style=“属性：值”&gt;</code></li><li>内嵌式 ： 一般放在（并不是必须）head里面，便于首先加载样式</li><li>外联式：<code>&lt;link rel=“stylesheet” href=“url” type=“text/css”&gt;</code>css文件只存在选择器和选择器包裹的样式，不存在标签对</li><li><p>导入式：@import“url”（只是声明，会等内容加载完之后再加载样式，不能被js调用）放在style里面的第一行或者在css文件的第一行。当有多个css文件的时候，可以使用导入式先导入到一个css文件中再导入到html中。</p><blockquote><p> <strong>外联式和内嵌式一般都放在head里面，便于首先加载。</strong></p></blockquote></li></ul></li></ul><a id="more"></a><h2 id="CSS选择器"><a href="#CSS选择器" class="headerlink" title="CSS选择器"></a>CSS选择器</h2><p>因为html和css分离了，那么就出现了如何选择一个元素将样式添加给它的问题，就此出现了选择器。</p><ul><li>选择器的语法<br>选择器后面跟着大括号{}，包裹一个或者多个声明。<br>通过不同的选择器可以选择不同的html元素<h3 id="标签选择器"><a href="#标签选择器" class="headerlink" title="标签选择器"></a>标签选择器</h3></li><li><strong>标签名{key：value；key：value；}</strong></li><li>可以批量选择“选择器名称相同的元素”，相当于人的姓</li><li>权重为1<h3 id="类选择器"><a href="#类选择器" class="headerlink" title="类选择器"></a>类选择器</h3></li><li><strong>.name{key：value；key：value；}</strong></li><li>一个html元素可以有多个类名如<code>&lt;p class=name1 name2&gt;</code></li><li>类名可以重复使用，相当于人的名</li><li>权重为10<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined">.title&#123;color:red;&#125;</span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">class</span>=<span class="string">"title title1"</span>&gt;</span>类选择器<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">class</span>=<span class="string">"title"</span>&gt;</span><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></div></pre></td></tr></table></figure></li></ul><h3 id="ID选择器"><a href="#ID选择器" class="headerlink" title="ID选择器"></a>ID选择器</h3><ul><li><strong> #name{key：value；key：value；}</strong></li><li>一个html元素，id属性值只能用一次，也就是说id具有唯一性（只能用一次）</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined">#title&#123;color:red;&#125;</span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">id</span>=<span class="string">"title"</span>&gt;</span>id选择器<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">id</span>=<span class="string">"title"</span>&gt;</span>错误的 不识别<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></div></pre></td></tr></table></figure><ul><li>权重为100</li></ul><h3 id="后代选择器（派生选择器）"><a href="#后代选择器（派生选择器）" class="headerlink" title="后代选择器（派生选择器）"></a>后代选择器（派生选择器）</h3><p> 可以在一个根元素范围内，查找它包含的后代元素<br> 语法：祖辈选择器空格要查找的后代选择器{}<br> 权重：选择器之和<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></div><div class="line">.div1 ul span&#123;&#125;</div><div class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"div1"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">span</span>&gt;</span>只选择了这个span元素<span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">ol</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">span</span>&gt;</span>wenzdskaldjaslk<span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">ol</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"div2"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">span</span>&gt;</span>wenzdskaldjaslk<span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">ol</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">span</span>&gt;</span>wenzdskaldjaslk<span class="tag">&lt;/<span class="name">span</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">ol</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure></p><blockquote><p>后代选择器在写的时候，尽量控制在三个左右</p></blockquote><h3 id="通配符选择器"><a href="#通配符选择器" class="headerlink" title="通配符选择器 *"></a>通配符选择器 *</h3><ul><li><strong>*{key：value；key：value；}</strong></li><li>匹配全部html元素</li><li>权重：0&lt;*&lt;1</li><li>一般不使用，因为全部匹配耗性能<br>###（标签）属性选择器<br>属性必须被中括号包裹</li><li><strong>[属性]{key：value；key：value；}</strong><ul><li>例子：[title（a的一个属性）]{key：value；key：value；} </li><li>权重：10</li></ul></li><li><strong>a[title]{key：value；key：value；}</strong><ul><li>利用标签的属性名和属性值来选择html元素</li><li>权重：11（标签+属性=1+10）</li></ul></li><li><strong>[属性=值]{key：value；key：value；}</strong> <ul><li>可以通过属性值的不同进行选择</li><li>权重：10,等同于<strong>[属性]{key：value；key：value；}</strong><blockquote><p>属性选择器我们不会使用class，因为class可以直接使用类选择器</p></blockquote></li></ul></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[class=div1]&#123;&#125;/*如果 class值有两个 不能这样使用*/</div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"div1 p1"</span> <span class="attr">id</span>=<span class="string">"div2"</span> <span class="attr">type</span>=<span class="string">""</span> <span class="attr">title</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure><h3 id="分组选择器（并集选择器）"><a href="#分组选择器（并集选择器）" class="headerlink" title="分组选择器（并集选择器）"></a>分组选择器（并集选择器）</h3><ul><li>作用（应用场景），同一份css样式，可以一次性的添加给多个不同的html元素</li><li>写法选择器1，选择器2，选择器3{key：value；key：value；}</li><li>权重：分组选择器将不同的html分为一组，权重计算的时候都是独立计算的，不会叠加。<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.box</span>,<span class="selector-tag">li</span>,<span class="selector-class">.p1</span>&#123;<span class="attribute">color</span>: yellow;&#125;</div><div class="line"><span class="selector-class">.box</span>&#123;<span class="attribute">color</span>: green;&#125;</div></pre></td></tr></table></figure></li></ul><h3 id="交集选择器"><a href="#交集选择器" class="headerlink" title="交集选择器"></a>交集选择器</h3><ul><li><strong>两种</strong>属性同属一个元素的时候，我们可以使用交集选择器来进行元素的准确选择</li><li>权重：所有组合选择器的权重之和</li><li>组合选择器之间<strong>没有任何的符号和空格</strong>，组合时如果有标签选择器，<strong>标签选择器要放在前面。</strong></li><li>作用：精确查找元素，增加选择器的权重  </li><li>组合规则：两个选择器可以是：标签和类名，标签和属性，标签和id，两个类选择器<h3 id="子集选择器"><a href="#子集选择器" class="headerlink" title="子集选择器"></a>子集选择器</h3>存在包含关系的元素选择器，通过父级确定选择子级<br>语法：父级选择器&gt;子级选择器{}<br>父级选择器是用来确定取值范围<br>子级选择器才是我们要添加样式的那个元素<br>权重：所有选择器之和 </li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></div><div class="line"><span class="selector-tag">ul</span>&gt;<span class="selector-tag">li</span>&#123;<span class="attribute">color</span>:red;&#125; <span class="comment">/*选择ul下的li*/</span></div><div class="line"><span class="comment">/*权重 2*/</span></div><div class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>M<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>M<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></div></pre></td></tr></table></figure><blockquote><p>子级选择器必须是紧邻的父子关系</p></blockquote><h3 id="相邻兄弟选择器"><a href="#相邻兄弟选择器" class="headerlink" title="相邻兄弟选择器"></a>相邻兄弟选择器</h3><p>通过哥哥元素选择弟弟元素，两个选择器之间用+相连<br>语法:哥哥选择器+弟弟选择器{}<br>权重：选择器之和<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></div><div class="line">    <span class="selector-class">.list1</span>+<span class="selector-tag">li</span>&#123;<span class="attribute">color</span>: red;&#125;</div><div class="line">    <span class="selector-class">.list3</span>+<span class="selector-tag">li</span>&#123;<span class="attribute">color</span>: green;&#125;</div><div class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"list1"</span>&gt;</span>11111<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>22222<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"list3"</span>&gt;</span>33333<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>4444<span class="tag">&lt;/<span class="name">li</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></div></pre></td></tr></table></figure></p><h3 id="伪类选择器"><a href="#伪类选择器" class="headerlink" title="伪类选择器"></a>伪类选择器</h3><p>给一个元素添加某种状态<br>例如：鼠标经过时，获取焦点时，鼠标点击时<br>权重：10<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></div><div class="line">        <span class="selector-tag">a</span><span class="selector-pseudo">:link</span>&#123;<span class="attribute">color</span>: blue;&#125;<span class="comment">/*a:link 是默认状态*/</span></div><div class="line">        <span class="selector-tag">a</span><span class="selector-pseudo">:hover</span>&#123;<span class="attribute">color</span>: red;&#125;<span class="comment">/*a:hover 是鼠标经过状态*/</span></div><div class="line">        <span class="selector-tag">a</span><span class="selector-pseudo">:active</span>&#123;<span class="attribute">color</span>: green;&#125;<span class="comment">/*a:active 是鼠标点击状态*/</span></div><div class="line">        <span class="selector-tag">a</span><span class="selector-pseudo">:visited</span>&#123;<span class="attribute">color</span>: blueviolet;&#125;<span class="comment">/*a:visited 鼠标点击后的状态*/</span></div><div class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript:void (0);"</span>&gt;</span>最初形态<span class="tag">&lt;/<span class="name">a</span>&gt;</span></div></pre></td></tr></table></figure></p><h3 id="伪元素选择器"><a href="#伪元素选择器" class="headerlink" title="伪元素选择器"></a>伪元素选择器</h3><p>通过css代码向指定元素内添加假的（html中不存在）元素<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></div><div class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:before</span>&#123;</div><div class="line">    <span class="attribute">display</span>: block;</div><div class="line">    <span class="attribute">content</span>: <span class="string">"我是before"</span>;</div><div class="line">    <span class="attribute">font-size</span>: <span class="number">40px</span>;</div><div class="line">    <span class="attribute">color</span>: white;</div><div class="line">&#125;</div><div class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:after</span>&#123;</div><div class="line">    <span class="attribute">display</span>: block;</div><div class="line">    <span class="attribute">content</span>: <span class="string">"我是after"</span>;</div><div class="line">    <span class="attribute">font-size</span>: <span class="number">60px</span>;</div><div class="line">    <span class="attribute">color</span>: aqua;</div><div class="line">&#125;</div><div class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></div></pre></td></tr></table></figure></p><p>before会出现在div之前<br>after会出现在div之后</p><blockquote><p>使用为元素的时候要保证两个前提</p><ul><li>要有display这个属性</li><li>要有cotent这个属性，这个属性的属性值可以为空，但是引号不可少，cotent：“”</li></ul></blockquote><h2 id="css属性的继承"><a href="#css属性的继承" class="headerlink" title="css属性的继承"></a>css属性的继承</h2><p>子级元素从父级元素身上继承一些可以继承的css属性<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></div><div class="line"><span class="selector-tag">div</span>&#123;<span class="attribute">color</span>:red;&#125;</div><div class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>我是一个p标签<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure></p><p>可以被继承的css样式：和文字与列表有关的样式可以被继承</p><p>如果css属性不带有继承性，如何继承父级身上的属性，可以将要继承的属性的属性值写上–inherit</p><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">ul</span>&#123;<span class="attribute">float</span>:left;&#125;</div><div class="line"><span class="selector-tag">li</span>&#123;<span class="attribute">float</span>:inherit;&#125; <span class="comment">/*float:inherit===float:left;*/</span></div></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> html，css </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>html+css笔记之二</title>
      <link href="/2015/03/15/html+css%E7%AC%AC%E4%BA%8C%E5%A4%A9%E7%AC%94%E8%AE%B0/"/>
      <url>/2015/03/15/html+css%E7%AC%AC%E4%BA%8C%E5%A4%A9%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>前端三层：HTML CSS JS (JAVASCRIPT)</li><li>网页（就是一个html文件）</li><li>网站（有很多网页组成）</li><li>站群（有很多网站组成）</li><li>标签（由尖括号和关键字（普通文本）组成的超文本）</li><li>关键字（普通文本），在编辑html这门语言的时候，相关组织将这些文本归纳到了一定的规则中，使他有了特殊的含义和作用</li><li>标签的分类：开始标签，结束标签，空标签</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;开始标签&gt;</div><div class="line">&lt;/结束标签&gt;</div><div class="line">&lt;空标签/&gt;</div></pre></td></tr></table></figure><ul><li>标签属性：他是用来描述标签功能的，一般写在开始标签中，跟在标签名的后面，用空格隔开，一个标签可以有很多标签属性，每一个属性都用空格隔开</li></ul><a id="more"></a>  <figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">开始标签</span>  属性名=<span class="string">“属性值”</span>  属性名=<span class="string">“属性值”</span>&gt;</span><span class="tag">&lt;/<span class="name">结束标签</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"url"</span> <span class="attr">alt</span>=<span class="string">"备注"</span>&gt;</span></div></pre></td></tr></table></figure><ul><li>元素：由标签（开始和结束标签中包含内容）和内容组成，元素中内容可以为空，一个空标签也叫做一个元素<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>content<span class="tag">&lt;/<span class="name">div</span>&gt;</span> -- &gt; div元素</div><div class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"url"</span> <span class="attr">alt</span>=<span class="string">"备注"</span> /&gt;</span>  -- &gt; img元素</div></pre></td></tr></table></figure></li></ul><blockquote><p>标签属性经过html的进化，舍弃了有关样式的标签属性，保留功能的标签属性<br>例如舍弃 width bgcolor align ，这些样式描述都放在css 里面<br>保留 alt、title src href…</p></blockquote><ul><li><p>常用的标签</p><ul><li>div标签是无意义标签，用来划分大区域</li><li>span 无意义标签 作用：<strong>行内</strong>小模块区分。</li><li>b作用：加粗</li><li>strong：加粗<strong>强调</strong></li><li>i 作用：<em>斜体</em></li><li>em 作用：<strong>强调*</strong>斜体*</li><li>p  段落</li><li>h1-h6 标题</li><li>a 超链接 锚点<ul><li><code>&lt;a href=&quot;javascript:void (0);&quot;&gt;</code></li></ul></li><li>dl 定义列表 （常用在新闻标题和摘要）<ul><li>dt  定义标题</li><li>dd 定义描述</li><li>一个dt可以有多个dd进行描述</li></ul></li><li>table 表格 <ul><li>caption 标题</li><li>thead 表头<ul><li>tr &gt; th(标题单元格)</li></ul></li><li>tfoot  表尾<ul><li>tr &gt; td(普通单元格)</li></ul></li><li>tbody 表身<ul><li>tr &gt; td(普通单元格)</li></ul></li></ul></li></ul><blockquote><p>thead和tfoot分别有一个 tbody可以有多个<br>tfoot一般放置在thead的后面，为了防止tbody中的内容过多，tfoot加载过慢的情况，但是虽然书写位置在前面，在页面中显示的时候，这部分依然在整个表格的最后面<br>如果table用来搭建结构，我们只需写tr和td</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></div></pre></td></tr></table></figure></blockquote></li><li><p>表单 获取用户信息 <code>&lt;form&gt;&lt;/form&gt;</code></p></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"ok"</span> <span class="attr">checked</span>=<span class="string">"checked"</span>&gt;</span><span class="comment">&lt;!--单选按钮--&gt;</span><span class="tag">&lt;<span class="name">label</span>&gt;</span>满意<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="comment">&lt;!--label 描述表单元素功能--&gt;</span></div><div class="line">    <span class="comment">&lt;!--type 类型--&gt;</span></div><div class="line">    <span class="comment">&lt;!--name 名字--&gt;</span></div><div class="line">    <span class="comment">&lt;!--checked 选中--&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"ok"</span>&gt;</span><span class="comment">&lt;!--单选按钮--&gt;</span><span class="tag">&lt;<span class="name">label</span>&gt;</span>不满意<span class="tag">&lt;/<span class="name">label</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span>&gt;</span><span class="tag">&lt;<span class="name">label</span>&gt;</span>篮球<span class="tag">&lt;/<span class="name">label</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">checked</span>&gt;</span><span class="tag">&lt;<span class="name">label</span>&gt;</span>美女<span class="tag">&lt;/<span class="name">label</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span>&gt;</span><span class="tag">&lt;<span class="name">label</span>&gt;</span>彭于晏<span class="tag">&lt;/<span class="name">label</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span>&gt;</span><span class="tag">&lt;<span class="name">label</span>&gt;</span>陈冠希<span class="tag">&lt;/<span class="name">label</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span>&gt;</span><span class="tag">&lt;<span class="name">label</span>&gt;</span>杨颖<span class="tag">&lt;/<span class="name">label</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span>&gt;</span><span class="tag">&lt;<span class="name">label</span>&gt;</span>维密<span class="tag">&lt;/<span class="name">label</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">textarea</span> <span class="attr">maxlength</span>=<span class="string">"10"</span> <span class="attr">minlength</span>=<span class="string">"1"</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span><span class="comment">&lt;!--文本域--&gt;</span></div><div class="line">    <span class="comment">&lt;!--maxlength 字符输入的最大长度--&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">label</span>&gt;</span>姓名<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">label</span>&gt;</span>手机<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">label</span>&gt;</span>密码<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></div></pre></td></tr></table></figure><h2 id="html的基本结构"><a href="#html的基本结构" class="headerlink" title="html的基本结构"></a>html的基本结构</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!doctype html&gt;</span></div><div class="line">文档声明：必须放在html文件的第一行，如果没有文档声明，会触发浏览器的怪异模式</div><div class="line">html元素：告知浏览器我是一个html文件</div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">head元素：文档的头部，一般放在文档头部的内容是不会显示在浏览器可视区内的</div><div class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>标题<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line">title中的内容也会被浏览器抓取</div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line">供用户浏览的所有内容，标签，图片，文本，视频。。。</div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div></pre></td></tr></table></figure><p>一个html文件也可以叫做一个网页，又可以称作是一个文档（document）<br>整个文档从html元素开始，一直向下分支延伸，像一棵大树一样，所以我们将html元素叫做这个文档的<strong>根元素</strong></p><p>##&lt;!DOCTYPE html&gt;文档声明<br>作用：定义这个文档的类型，浏览器先识别这句话。会按照定义的类型去解析这个文档<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line">html5的文档声明，浏览器就会按照html5的规则解析这个文档</div><div class="line">同样html4的文档，浏览器就会按照4的规则解析这个文档</div></pre></td></tr></table></figure></p><blockquote><p>所有高版本都会向下兼容，所以可以把所有的版本都写成html5的声明</p><p>文档声明必须写在html文件的第一行</p><p>文档声明不区分大小写</p><p>如果html文件没有文档声明，会触发浏览器的怪异模式</p><p>文档声明不是一个html标签</p></blockquote><h3 id="html元素"><a href="#html元素" class="headerlink" title="html元素"></a>html元素</h3><p>此元素告诉浏览器其自身是一个html文档<br>是由开始和结束标签组成的。</p><p>###head元素<br>整个文档的头部，head元素自带隐藏功能，display： none<br>里面的内容不会隐藏，只不过一般放置在head元素中的其他元素和内容也是自带隐藏功能的，例如link、meta</p><h3 id="lt-meta-gt-规定了html文档的原信息"><a href="#lt-meta-gt-规定了html文档的原信息" class="headerlink" title="&lt;meta&gt;规定了html文档的原信息"></a><code>&lt;meta&gt;</code>规定了html文档的原信息</h3><ul><li>charset=UTF-8 文档的编码<ul><li>utf-8国际通用编码</li><li>gbk</li><li>gb2312</li></ul></li><li>name=”keyword” content=”HTML5,JS….”<br>关键词  SEO优化  <h3 id="title元素"><a href="#title元素" class="headerlink" title="title元素"></a>title元素</h3>html文档名称一个页面只有一个title元素<br>文字显示在浏览器的页卡（页头）位置<h3 id="link"><a href="#link" class="headerlink" title="link"></a>link</h3></li><li><p><code>&lt;link href=&quot;favicon.ico&quot; type=&quot;image/x-icon&quot; rel=&quot;shortcut icon&quot;&gt;</code></p><ul><li>图标让设计师生成</li><li>一般这个图片放在整个项目的根目录下</li><li>显示在浏览器页卡位置，title内容之前</li></ul></li><li><p><code>&lt;link rel=&quot;stylesheet&quot; href=&quot;url&quot; type=&quot;text/css&quot;&gt;</code></p><ul><li>引入一个外部的css文件</li><li>rel 不能缺少     stylesheet 样式表</li><li>type 可以省略 但是建议写全<h3 id="body元素"><a href="#body元素" class="headerlink" title="body元素"></a>body元素</h3>定义整个文档的主体部分，所有展示给用户的内容，都要放在这个元素中，<br>body中有常用的html元素（div ul），文本内容、音频、视频、图片、表单… …</li></ul></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure><h2 id="标签语义化"><a href="#标签语义化" class="headerlink" title="标签语义化"></a>标签语义化</h2><p>head标签就知道是文档头部<br>浏览器会按照每个标签的意义去解析标签中的内容<br>h1是个大标题，意义很重要，搜索引擎会重点抓取这个里面的内容</p><p>p–&gt; 段落，浏览器在展现这一部分的时候，会独立成一块，让文档结构更加清晰，给用户更好的交互体验。</p><p>作用：</p><ul><li>重要的内容要放在语义重要的标签中，利于SEO优化（搜索引擎抓取）</li><li>在没有css的情况下也可以清晰的展示文档内容</li><li>利于团队和做和后期维护<br>在日常工作中如何遵循标签语义化<br>  1、尽量减少使用无意义标签，例如span和div；<br>  2、尽量不使用标签本身的css属性，例如b、font、s等标签，如果需要这些样式，那么使用css样式来进行添加；<br>  3、在需要强调的部分，使用strong、em，但是样式尽量使用css样式来描述；<br>  4、表格搭建时，使用<code>&lt;thead&gt;表格头部&lt;/thead&gt;</code> <code>&lt;tbody&gt;表格身体&lt;/tbody&gt;</code> <code>&lt;tfoot&gt;表格尾部&lt;/tfoot&gt;</code>；<br>  5、列表搭建时，使用<code>&lt;ul&gt;无序列表&lt;/ul&gt;</code> <code>&lt;ol&gt;有序列表&lt;/ol&gt;</code> <code>&lt;dl&gt;定义列表&lt;/dl&gt;</code>；</li></ul><p>国家评比一个网站的关键点：访问量（流量 点击量）</p><p>iframe 在引入其他文件的时候，<strong>必须写宽度和高度</strong></p><h2 id="CSS层叠样式表"><a href="#CSS层叠样式表" class="headerlink" title="CSS层叠样式表"></a>CSS层叠样式表</h2><ul><li>css的作用？</li><li>css和html怎么结合到一起的？</li><li>在css文件中，如何选择一个html元素，将样式添加给这个元素？</li></ul><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>给html文档添加静态或者动态的样式</p><h3 id="html引入css的四种方式"><a href="#html引入css的四种方式" class="headerlink" title="html引入css的四种方式"></a>html引入css的四种方式</h3><h4 id="行内式"><a href="#行内式" class="headerlink" title="行内式"></a>行内式</h4><p>直接写在标签内，通过标签属性style引入</p><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"css属性名:属性值;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">style</span>=<span class="string">"css属性名:属性值;"</span> <span class="attr">alt</span>=<span class="string">""</span> /&gt;</span></div></pre></td></tr></table></figure><h4 id="内嵌式（内联式）"><a href="#内嵌式（内联式）" class="headerlink" title="内嵌式（内联式）"></a>内嵌式（内联式）</h4><p>将css代码写在style元素内，通过css选择器选择html元素，将css样式添加个这个元素</p><ul><li>style这个元素，一般放在head元素内</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></div><div class="line"><span class="selector-tag">div</span>&#123;<span class="attribute">height</span>:<span class="number">100px</span>;&#125;</div><div class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure><h4 id="外联式（外链式）"><a href="#外联式（外链式）" class="headerlink" title="外联式（外链式）"></a>外联式（外链式）</h4><p>将css代码单独放置在一个css文件中，再通过link标签将这个css文件引入到html文件中<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"url"</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span></div></pre></td></tr></table></figure></p><h4 id="导入式"><a href="#导入式" class="headerlink" title="导入式"></a>导入式</h4><p>@import “url”; 都是引入一个单独的css文件</p><ul><li>@import “url”; 既不是html标签，也不是css属性，他是一条声明语句</li><li>这条语句必须写在style元素内，或者css文件内</li><li>这条语句必须在所在文件内的第一行</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></div><div class="line">@<span class="keyword">import</span> <span class="string">"url"</span>;</div><div class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></div></pre></td></tr></table></figure><h4 id="外联式和导入式的差别："><a href="#外联式和导入式的差别：" class="headerlink" title="外联式和导入式的差别："></a>外联式和导入式的差别：</h4><ul><li>link和@import虽然都是引入外部的css文件，但是他们是由天差地别的区别的</li><li>link是html标签，@import完全是css提供的方式，要写在css文件或者style标签中。</li><li>他们的加载顺序也是有区别的，当一个页面被加载的时候，link引用的css文件会被同时加载，而@import引入的css文件会等页面全部下载完后再加载。</li><li>当使用javascript控制DOM去改变css样式的时候，只能使用link标签，因为import是不能被DOM控制的。</li></ul><h4 id="四种引入方式的权重："><a href="#四种引入方式的权重：" class="headerlink" title="四种引入方式的权重："></a>四种引入方式的权重：</h4><p>一个html元素最终加载的css样式是谁决定的<br>有行内式的时候，听行内的<br>在选择器相同的情况下，谁最后加载就听谁的</p>]]></content>
      
      
        <tags>
            
            <tag> html，css </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>html+css笔记之一</title>
      <link href="/2015/03/01/html+css%E7%AC%AC%E4%B8%80%E5%A4%A9%E7%AC%94%E8%AE%B0/"/>
      <url>/2015/03/01/html+css%E7%AC%AC%E4%B8%80%E5%A4%A9%E7%AC%94%E8%AE%B0/</url>
      <content type="html"><![CDATA[<h3 id="前端三层"><a href="#前端三层" class="headerlink" title="前端三层"></a>前端三层</h3><ul><li>HTML 结构 是被浏览器直接解析加载</li><li>CSS 样式 是在html结构之上去装点网站</li><li>javascript 交互 动态效果/数据交互  </li></ul><h3 id="网页"><a href="#网页" class="headerlink" title="网页"></a>网页</h3><p>网页是构成网站的基本元素，通俗来讲一个html文件就是一个网页。</p><h3 id="网站"><a href="#网站" class="headerlink" title="网站"></a>网站</h3><p>是由很多个网页组成的，共同为一个目标服务的网页集合。</p><h3 id="站群-（流水线统一化管理）"><a href="#站群-（流水线统一化管理）" class="headerlink" title="站群 （流水线统一化管理）"></a>站群 （流水线统一化管理）</h3><a id="more"></a><p>由很多网站组成的，为同一个公司服务。<br>例如整个百度下所属的子公司都有自己的网站，百度搜索、糯米、音乐、手机助手、百度金融…。</p><h3 id="HTTP（超文本传输协议）"><a href="#HTTP（超文本传输协议）" class="headerlink" title="HTTP（超文本传输协议）"></a>HTTP（超文本传输协议）</h3><p>HyperText Transfer Protocol<br>在万维网上提供一种发布和接收HTML页面（网页）的方法<br>步骤：</p><ul><li>建立连接：输入网址，建立客户端和服务器端的连接</li><li>发送请求信息：客户端发送一个请求给服务器</li><li>发送响应信息：服务器接到请求后，给予相应的响应信息</li><li>关闭连接：客户端接收服务器所返回的信息通过浏览器显示在用户的显示屏上，然后客户机与服务器断开连接</li></ul><h3 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h3><p>服务器，是提供计算服务的设备。由于服务器需要响应服务请求，并进行处理，因此一般来说服务器应具备承担服务并且保障服务的能力。</p><p>在网络环境下，根据服务器提供的服务类型不同，分为文件服务器，数据库服务器，应用程序服务器，WEB服务器等。</p><p>防篡改：web端服务器一旦受到攻击，在0.0n秒作出反应，将内网服务器中的内容，马上覆盖在web端服务器上</p><p>负载均衡：平均web服务器压力，将用户访问进行分流</p><p>VPN：用来翻墙，有指定账号就可以通过这个产品进行内网访问</p><h3 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h3><p>浏览器是指可以显示网页服务器或者文件系统的HTML文件（标准通用标记语言的一个应用）内容，并让用户与这些文件交互的一种软件</p><p>html、css、js都是运行在这个软件中，浏览器是一个工厂，html、css、js是工人和原料</p><p>IE6  –&gt; IE7(很快淘汰) –&gt; IE8(时间较长，稳定性好) –&gt; IE9(半年-一年) –&gt; IE10 –&gt; IE11 –&gt; IE(Edge)</p><p>对开发者最友好的浏览器 –&gt; 谷歌</p><h3 id="网页的基本组成"><a href="#网页的基本组成" class="headerlink" title="网页的基本组成"></a>网页的基本组成</h3><p>HTML：是网页的骨架，支撑起血肉（文字、图片、音视频…）<br>CSS：表皮和衣服、化妆品<br>javascript：动态和交互</p><h3 id="HTML-（超文本标记语言）"><a href="#HTML-（超文本标记语言）" class="headerlink" title="HTML （超文本标记语言）"></a>HTML （超文本标记语言）</h3><p>网页文件本身是一种文本文件（除了文字再无其他），只有通过特定的标记描述，那些普通文本才能在浏览器中正常的显示，在页面中如果遇到图片，音视频的时候如何用文本描述，需要用超文本进行引入才可以正常显示</p><h4 id="html文件的特点"><a href="#html文件的特点" class="headerlink" title="html文件的特点"></a>html文件的特点</h4><p>浏览器根据标记来解析和描述内容（从html的第一行开始向下解析），如果遇到错误，浏览器不会指出，也不会报错，会跳过此处继续加载，编辑人员需要根据显示效果去分析哪里出错误了 – html不会报错</p><h4 id="html的兼容问题"><a href="#html的兼容问题" class="headerlink" title="html的兼容问题"></a>html的兼容问题</h4><p>因为浏览器是由不同厂商生产的，所以对html的解析有分歧，产生了页面效果显示不一致的情况，我们将这个问题，叫做兼容问题。</p><h3 id="超文本-（标签）"><a href="#超文本-（标签）" class="headerlink" title="超文本 （标签）"></a>超文本 （标签）</h3><h4 id="标签语法"><a href="#标签语法" class="headerlink" title="标签语法"></a>标签语法</h4><p>由成对的尖括号和关键字(标签名 tagName)组成，叫做标签 <code>&lt;tagName&gt;</code></p><p>关键字（标签名）：是已经规范过的，不是自己随便制造的<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">例如：</div><div class="line"><span class="tag">&lt;<span class="name">亓智</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">公维懿</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">吕堃鹏</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">h2</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">img</span> /&gt;</span></div></pre></td></tr></table></figure></p><h4 id="标签属性"><a href="#标签属性" class="headerlink" title="标签属性"></a>标签属性</h4><p>属性提供了有关 HTML 元素的更多的信息<br>语法：由属性名和属性值组成（键值对 key=’value’）<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;span style=<span class="string">"font-family: 宋体;"</span> title=<span class="string">"标题"</span>&gt;</div><div class="line">span 是标签名</div><div class="line">style 是标签属性名</div><div class="line"><span class="string">"font-family: 宋体;"</span> 标签属性值</div></pre></td></tr></table></figure></p><p>一个标签可以有很多标签属性，每一个属性之间用空格隔开</p><h4 id="标签的分类"><a href="#标签的分类" class="headerlink" title="标签的分类"></a>标签的分类</h4><ul><li>开始标签   <code>&lt;div&gt;</code></li><li>结束标签   <code>&lt;/div&gt;</code></li><li>自闭合标签（空标签） <code>&lt;br /&gt;</code></li></ul><h3 id="HTML的元素"><a href="#HTML的元素" class="headerlink" title="HTML的元素"></a>HTML的元素</h3><p>可以将元素理解成一个容器，容器中放置的就是我们网页中的主要内容</p><blockquote><p>内容可以为空</p></blockquote><p>由标签和内容组成的，叫做元素<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>此处是内容<span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure></p><h4 id="元素分类"><a href="#元素分类" class="headerlink" title="元素分类"></a>元素分类</h4><ul><li>由开始标签和结束标签组成的元素，可以进行嵌套（一个元素包着另一个元素），元素中可以添加内容</li><li>只有一个空标签，只能进行功能的添加，例如 img 元素，用来引入图片，br 用来进行换行</li></ul><blockquote><p>标签和元素是用来标记和描述内容的，所以这些标签和元素用户是看不到的，用户只能看到这个元素中的内容</p></blockquote><h3 id="常用的html元素有哪些"><a href="#常用的html元素有哪些" class="headerlink" title="常用的html元素有哪些"></a>常用的html元素有哪些</h3><table><thead><tr><th style="text-align:left">标签名</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">div</td><td style="text-align:left">无意义标签 用来区分网页大模块，例如网页头部，主体内容，尾部</td></tr><tr><td style="text-align:left">span</td><td style="text-align:left">无意义标签 用来描述行内某个小模块</td></tr><tr><td style="text-align:left">p</td><td style="text-align:left">段落</td></tr><tr><td style="text-align:left">ul</td><td style="text-align:left">无序列表</td></tr><tr><td style="text-align:left">ol</td><td style="text-align:left">有序列表</td></tr><tr><td style="text-align:left">b</td><td style="text-align:left">加粗</td></tr><tr><td style="text-align:left">strong</td><td style="text-align:left">加粗 浏览器解析的时候 有强调作用</td></tr><tr><td style="text-align:left">body</td><td style="text-align:left">身体 网页主体部分 （内容在浏览器的可视区显示）</td></tr><tr><td style="text-align:left">a</td><td style="text-align:left">超链接 锚点</td></tr><tr><td style="text-align:left">img</td><td style="text-align:left">引入图片</td></tr></tbody></table>]]></content>
      
      
        <tags>
            
            <tag> html，css </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>预解释</title>
      <link href="/2015/03/01/%E9%A2%84%E8%A7%A3%E9%87%8A/"/>
      <url>/2015/03/01/%E9%A2%84%E8%A7%A3%E9%87%8A/</url>
      <content type="html"><![CDATA[<ul><li><p>预解释:是一个过程,<strong>作用域形成之后,代码执行之前</strong>,把所有带关键字var和function的提前声明或定义.(也叫做变量提声)</p><blockquote><p>预解释过的东西,在代码执行的时候不会再重复操作</p></blockquote></li><li><p>作用域:</p><ul><li>全局作用域:window下,一打开浏览器就会形成</li><li>私有作用域:一个函数就是一个私有作用域,函数一执行就会形成私有作用域</li></ul></li><li>声明:告诉浏览器这里有个变量,带var关键字的只有声明</li><li>定义:赋值过程,在预解释的时候function既声明又定义<blockquote><p> 预解释的时候遇到变量已经声明过了就不用声明了,但是需要重新定义</p></blockquote></li></ul><a id="more"></a><h2 id="预解释的特殊情况"><a href="#预解释的特殊情况" class="headerlink" title="预解释的特殊情况"></a>预解释的特殊情况</h2><ul><li>1.=右边不进行预解释(函数作为值的时候)</li><li>2.return 下面的代码不执行,但是需要预解释,return后的内容执行但是不进行预解释</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> a=<span class="number">0</span>;</div><div class="line">        <span class="built_in">console</span>.log(f);<span class="comment">//fn执行的时候函数f会被输出</span></div><div class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;<span class="comment">//这个return后面的函数不会被预解释</span></div><div class="line">            <span class="built_in">console</span>.log(<span class="number">1</span>);</div><div class="line">        &#125;;</div><div class="line">        <span class="function"><span class="keyword">function</span>  <span class="title">f</span>(<span class="params"></span>) </span>&#123;<span class="comment">//此函数在return下面,不会被执行,但是预解释的时候要对其进行预解释.</span></div><div class="line"></div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure><ul><li>3.条件中,不管条件是否成立{}的代码都进行预解释<ul><li><strong>注意</strong>:var 和function只声明,不定义,声明的时候遇到变量名已经被声明过了,就会报错.</li><li>代码执行的时候,条件一旦成立,上来先给函数赋值(函数定义),然后再去执行代码.</li></ul></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(num);</div><div class="line">    <span class="keyword">if</span>(<span class="number">0</span>)&#123;</div><div class="line">        <span class="keyword">var</span> num=<span class="number">0</span>;<span class="comment">//虽然条件不成立,但是需要预解释.</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">var</span> ss=<span class="number">0</span>;<span class="comment">//window.ss=0</span></div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"ss"</span> <span class="keyword">in</span> <span class="built_in">window</span>);<span class="comment">//输出的结果是true,证明"ss"是window的属性</span></div></pre></td></tr></table></figure><ul><li>4.自执行函数 不进行预解释</li><li>5.函数作为参数的时候不进行预解释</li><li>6.预解释的时候遇到已经声明过的变量(函数)不需要声明了,但是需要定义.</li></ul><blockquote><p>注意:全局作用域下的变量就是window的一个属性.带var的预解释声明的时候就给window增加了属性,不带var的执行的时候给window增加属性.</p></blockquote><h2 id="代码执行过程"><a href="#代码执行过程" class="headerlink" title="代码执行过程"></a>代码执行过程</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(obj1);</div><div class="line">    <span class="keyword">var</span> obj1=&#123;<span class="attr">name</span>:<span class="string">"111"</span>&#125;;</div><div class="line">    <span class="built_in">console</span>.log(fn);</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;&#125;;</div></pre></td></tr></table></figure><ul><li>1.全局作用域的形成</li><li>2.预解释:<code>var obj1, function fn=xxxfff000</code></li><li>3.代码执行: 1)<code>console.log(obj1);此时obj1</code>只声明了没有定义,所以输出的是undefined<ul><li>1)<code>console.log(obj1);</code>此时obj1只声明了没有定义,所以输出的是undefined</li><li>2)<code>obj1=xxxfff111</code>此过程为赋值,引用数据类型赋的值是一个引用地址.</li><li>3)<code>console.log(fn);</code>预解释的时候已经被声明和定义,所以直接执行.输出了函数本身<h2 id="内存分类"><a href="#内存分类" class="headerlink" title="内存分类"></a>内存分类</h2></li></ul></li><li>堆内存:存出东西,一般都是存引用数据类型</li><li>栈内存:作用域</li></ul><h2 id="私有作用域"><a href="#私有作用域" class="headerlink" title="私有作用域"></a>私有作用域</h2><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><ul><li>闭包:是一种机制,函数执行的时候会形成一个私有作用域,来保护里面的变量不受外界的干扰,我们把这种机制叫做闭包.<h3 id="私有变量"><a href="#私有变量" class="headerlink" title="私有变量"></a>私有变量</h3></li><li>1.参数</li><li>2.在私有作用域下预解释的变量.<blockquote><p>私有作用域下的私有变量外界访问不到,但是私有作用域可以获取外界的变量.</p></blockquote></li></ul><h3 id="上级作用域查找"><a href="#上级作用域查找" class="headerlink" title="上级作用域查找"></a>上级作用域查找</h3><p>查找上一级作用域: 看当前这个函数<strong>对应的堆内存</strong>是在哪个作用域下定义的,那么他的上一级就是这个作用域,和在哪里执行没有关系.</p><h3 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h3><p>在私有作用域下遇到变量先看是不是自己的私有变量(两种),是的话就是私有的,不是的话就是往上一级找,如果还没有,就继续找,知道找到全局位置,还没有找到就报错了,这种<strong>查找机制</strong>叫做作用域链.</p><h3 id="函数的赋值过程"><a href="#函数的赋值过程" class="headerlink" title="函数的赋值过程:"></a>函数的赋值过程:</h3><ul><li>1.浏览器检测他是什么数据类型的,是函数的话,浏览器就给它开辟一个堆内存</li><li>2.将函数当做字符串存起来</li><li>3.将地址赋值给函数名</li></ul><h3 id="函数执行过程"><a href="#函数执行过程" class="headerlink" title="函数执行过程"></a>函数执行过程</h3><ul><li>1.形成私有作用域(只有执行的时候会形成)</li><li>2.有形参的话给形参赋值,相当于var一个变量并赋值,<code>function s(a){};s(1)--&gt;a=1</code></li><li>3.预解释</li><li>4.函数体执行</li></ul><h3 id="内存的销毁机制"><a href="#内存的销毁机制" class="headerlink" title="内存的销毁机制"></a>内存的销毁机制</h3><ul><li>1.<strong>堆内存</strong>:只要这个堆内存没有被任何变量或者属性占用,浏览器就会主动的将他销毁,其他的需要手动销毁,注意以后再做项目的时候遇到一个对象后面不用了,手动清空一下,obj=null;</li><li><p>2.栈内存(作用域):</p><ul><li>全局作用域:关闭浏览器的时候销毁,做项目的时候尽量避免全局变量的使用.</li><li><p>私有作用域:相同的函数每一次执行都会形成一个私有的作用域,他们之间没有任何的关系.</p><ul><li><p>1)立即销毁:函数没有返回值,或者返回的内容没有被占用,浏览器就会把它销毁</p></li><li><p>2)暂时不销毁:函数返回了一个函数,这个返回的函数接着执行了,完了之后浏览器会抽时间销毁(具体什么时候销毁与每个浏览器的机制不一样)</p></li><li><p>3)不销毁:一,函数执行返回一个地址,一直被外界变量占用着,则私有作用域不销毁;二,在一个私有的作用域中给DOM元素绑定方法,私有作用域不销毁</p></li></ul></li></ul></li></ul><p>立即销毁<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> n=<span class="number">1</span>;</div><div class="line">        <span class="built_in">console</span>.log(n++);</div><div class="line">    &#125;</div><div class="line">    fn1();</div><div class="line">    fn1();</div><div class="line">    <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="string">"销毁"</span>)</div><div class="line">    &#125;</div><div class="line">    fn();<span class="comment">//这个函数执行完后,对后面没有什么影响就销毁了.</span></div></pre></td></tr></table></figure></p><p>不销毁1</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>) </span>&#123;</div><div class="line">       <span class="keyword">var</span> n=<span class="number">0</span>;</div><div class="line">       <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">           <span class="built_in">console</span>.log(n++);</div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">   <span class="keyword">var</span> f=fn2();<span class="comment">//当函数返回一个函数的时候,被外界的变量接收了,作用域不能销毁.</span></div></pre></td></tr></table></figure><p>不销毁2<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//作用域不销毁这个概念主要是用在给元素绑定事件的时候.</span></div><div class="line"><span class="keyword">var</span> box=<span class="built_in">document</span>.getElementById(<span class="string">"box"</span>);</div><div class="line">    box.onclick=<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">var</span> n=<span class="number">0</span>;</div><div class="line">        <span class="built_in">console</span>.log(n)</div><div class="line">    &#125;;</div></pre></td></tr></table></figure></p><p>不销毁3<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> olis=<span class="built_in">document</span>.getElementsByTagName(<span class="string">"ul"</span>)[<span class="number">0</span>].getElementsByTagName(<span class="string">"li"</span>);</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;olis.length;i++)&#123;</div><div class="line">        olis[i].i=i;</div><div class="line">        olis[i].onclick=(<span class="function"><span class="keyword">function</span> (<span class="params">j</span>) </span>&#123;<span class="comment">//j是自执行函数的形参</span></div><div class="line">            <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">                <span class="built_in">console</span>.log(j);</div><div class="line">            &#125;</div><div class="line">        &#125;)(i);<span class="comment">//给自执行函数传入实参(i)</span></div><div class="line">    &#125;</div></pre></td></tr></table></figure></p><blockquote><p><code>box.onclick=function (e) {}</code>  给元素通过这种方式绑定事件的时候,不要加参数,参数表示的是事件对象</p></blockquote>]]></content>
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
  
  
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      <content type="html"><![CDATA[]]></content>
    </entry>
    
  
</search>
