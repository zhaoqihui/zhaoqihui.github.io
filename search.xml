<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[myname]]></title>
    <url>%2F2017%2F12%2F01%2Ftry%2F</url>
    <content type="text"><![CDATA[hahhahahhahah]]></content>
  </entry>
  <entry>
    <title><![CDATA[在hexo中展示markdown文件中的图片]]></title>
    <url>%2F2017%2F07%2F26%2F%E5%9C%A8hexo%E4%B8%AD%E5%B1%95%E7%A4%BAmarkdown%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"><![CDATA[使用本地路径：在hexo/source目录下新建一个img文件夹，将图片放入该文件夹下，插入图片时链接即为/img/图片名称。使用微博图床，地址http://weibotuchuang.sinaapp.com/，将图片拖入区域中，会生成图片的URL，这就是链接地址。]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery中常用的属性方法]]></title>
    <url>%2F2017%2F04%2F21%2FJQ%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E5%B1%9E%E6%80%A7%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[闲来无事把jquery中最常用的方法来整理一下！ 1.回调函数集合$.Callbacks()123456789101112function f1(a) &#123;console.log("f1:" + a);&#125;function f2(a,b) &#123;console.log("f2:" + a + b);&#125;f1(1);f2(1,1);var $call=$.Callbacks();//回掉函数集合$call.add(f1);$call.add(f1,f2);//向回掉函数集合中增加方法$call.fire(1,2);//fire去依次执行里面的函数,可以给传参数,函数执行的时候自动获取对应的参数$call.remove(f1);//删除回掉函数集合中的f1方法console.log($call.has(f1));//false//has判断回掉函数集合中有没有这个函数//$call.empty();//清空回掉函数集合中的所有函数 常用方法 add(f1,f2)向回调函数集合中增加方法,增加多个时用”,”隔开 fire(1,3)依次执行增加到回调函数集合中的函数,可以给传参数,函数执行的时候自动获取对应的参数 remove(f1,f2)删除向回调函数集中添加的方法,删除多个方法用”,”隔开 has(f1)判断回调函数集合中有没有这个函数,多个参数用”,”隔开. empty()清空集合中错有自己添加进去的函数. 2.属性attr(),获取/设置属性一般都是自定义属性,会显示在html标签上 一个参数是获取值 两个参数是设置属性值 参数可以是一个对象—&gt;批量设置属性值 removeAttr(),移除属性$(&quot;#box&quot;).removeAttr(&quot;a&quot;)删除单个$(&quot;#box&quot;).removeAttr(&quot;a b&quot;)移除多个属性,属性之间用空格隔开. prop(),获取/设置属性一般都是自带的内置属性 如果设置的是内置属性就会显示在html结构上,如果是自定义 属性不会显示在html就够上 3.class类名操作 addClass可以同时添加多个类名,类名与类名之间用空格隔开 removeClass toggleClass hasClass4.关于jQ中遍历的方法each()遍历jQ集合的(和数组中的forEach很像) 参数是个函数这个函数默认执行的时候给他传了两个参数,第一个是索引(index),第二个是当前项(item是一个原生对象)12345678910$("#oUl&gt;li").each(function (index,item) &#123; //this是当前的item //item 原生对象 //给每个li增加一个class名"JQ" $(item).addClass("JQ"); //$(this).addClass("JQ"); item.innerHTML++; //this.innerHTML++; item.className+=" JQ" &#125;) map()跟each一样,只是他有返回值1234var $map=$("#oUl&gt;li").map(function (index,item) &#123; console.log(index, item); return this.innerHTML; &#125;) 作为参数的函数中this是当前项即item,item是个原生对象,所以this也是,如果想使用jQ方法就要将其转为jQ对象—&gt;$(this) 5. css()样式获取/设置样式,可以批量设置 6.尺寸属性全部都没有单位 offset()当前元素距离body的偏移量,返回值是一个对象{left:&quot;距离&quot;,top:&quot;距离&quot;}offset().top/offset.left,没有单位 scro llTop()/scrollLeft ()不传参数是获取,传参数是修改,没有单位 width()/height()不传参数是获取,传参数是修改.没有单位 innerWidth()/innerHeight()跟原生的client系列一样不传参数是获取,传参数是修改(改的是宽高,padding不变) outerWidth()/outerHeight()相当于offset系列(offsetWidth/offsetHeight)不传参数是获取,传参数是修改,修改的时候padding+border不变,改变的是宽高. 注意:outerWidth(true)/outerHeight(true),是获取并且加上margin. 7.文档处理append父级.append(新元素)加在父级元素中的最后面123var oDiv=document.createElement("div"); $(".box1").append(oDiv);//添加的元素可以是原生对象 $(".box1").append($("#p1"));//也可以是jQ对象 appendTo新元素.appendTo(父级)$(&quot;#p1&quot;).appendTo(&quot;.box&quot;); prepend/prependTo加在父级元素中的最前面$(&quot;#box&quot;).prepend($(&quot;#p1&quot;));$(&quot;#p1&quot;).prependTo$(&quot;#box&quot;) after/before加在当前元素的后面/前面$(&quot;.box&quot;).after($(&quot;#p1&quot;)); insertBefore/insertAfterjQ选择出来的元素.insertBefore(指定元素)jQ选择出来的元素.insertAfter(指定素) replaceAll$(&quot;.box1&quot;).replaceAll(&quot;#p1&quot;);将#p1元素替换成.box1元素 remove$(&quot;div&quot;).remove(&quot;.box1&quot;);把所有div中类名是box1的删掉 筛选eq(),first(),last()12345var $li=$("ul&gt;li"); $li[0];//元素 原生对象 $li.eq(0);//JQ对象 $li.first(0);//JQ对象 $li.last(0);//JQ对象 filter同级过滤$(&quot;ui&gt;li&quot;).filter(&quot;.li1&quot;);在所有的li中找类名是li1的li元素 子级过滤$(&quot;ul&quot;).children(&quot;.li1&quot;);在ul下找类名是li1的孩子元素 后代过滤$(&quot;ul&quot;).find(&quot;.li1&quot;);在ul后代中找类名是li1的后代 DOM操作parent()/parents()$(&quot;.box1&quot;).parent();一个父级元素$(&quot;.box1&quot;).parents();所有的父级元素(父亲,父亲的父亲…..) next(),prev()分别是下一个弟弟和上一个哥哥 nextAll(),prevAll()分别是所有的弟弟和所有的哥哥 siblings()所有的兄弟 JQ中常用的动画方法在JQ中加动画的时候,在加动画之前先执行以下stop(),因为先要停止上一个动画去开启下一个动画 hide()/show()隐藏/显示$box.stop().hide();$box.stop().show();参数可以是”slow”,”fast”,”数字’ slideUp()/slideDown()收起来/展开$box.stop().slideUp();$box.stop().slideDown();参数可以是”slow”,”fast”,”数字’ fadeIn()/fadeOut 淡入淡出$box.stop().fadeIn();$box.stop().fadeOut();参数可以是”slow”,”fast”,”数字’ fadeToggle()自动淡入淡出delay(时间)延迟动画$box.stop().delay(3000).slideDown()对hide()和show()没有效果 animate({目标值},duration,回调函数function)12345678910$box.animate(&#123;top:600,height:100&#125;,2000,function () &#123; //this当前执行动画的元素 this.innerHTML="哈哈" console.log(this); $(this).css("backgroundColor","red"); $(this).animate(&#123;top:80,height:50&#125;,2000,function () &#123; this.innerHTML=""; $(this).css("backgroundColor","yellowgreen"); &#125;)&#125;); JQ中的小技巧鼠标右键的禁用12345678$(document).contextmenu(function () &#123; console.log(this);//document //return false是阻止事件默认行为的方法 return false&#125;);$("a")[0].onclick=function () &#123; return false;//阻止a标签的默认跳转行为&#125; 鼠标的键值12345$("#box").mousedown(function (e) &#123; //e是事件对象 console.log(e.which); //右键:3,左键:1,中间:2 &#125;); 自定义选择器12345678var select="widthMore50px";//选择宽度大于50px的元素$.expr[":"][select]=function (a) &#123; //return后面的是条件 return $(a).width()&gt;50;&#125;;console.log($("div"));console.log($("div:widthMore50px")); 关闭动画jQuery.fx.off=false页面上动画有效果jQuery.fx.off=true关掉页面上动画效果123456789$("#box").click(function () &#123; $(".box2").stop().slideToggle();&#125;);$("#close").click(function () &#123; jQuery.fx.off=true;&#125;);$("#open").click(function () &#123; jQuery.fx.off=false;&#125;); 改变this$.proxy(函数,改变的this)1234567function f1() &#123; console.log(this.a);&#125;var a=0;var obj=&#123;a:"a",f1:f1&#125;;f1();$.proxy(f1, obj)();//--&gt;输出"a";]]></content>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery中的选择器]]></title>
    <url>%2F2017%2F04%2F20%2FjQuery%E4%B8%AD%E7%9A%84%E9%80%89%E6%8B%A9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[jQuery中的选择器用jQ选择器选择出来的是个jQ对象,他只能用jQ中提供的方法,不能用原生的方法和属性 如何把一个jQ对象变成原生对象 1.$(&quot;#box&quot;)[0] 2.$(&quot;#box&quot;).get(0) 把原生对象变成一个JQ对象通过JQ选择器 1.基本选择器id选择器$(&quot;#box&quot;)获取得是一个 JQ对象 类选择器$(&quot;.box&quot;)获取的是JQ集合 通配符选择器(*)$(&quot;*&quot;)获取的是JQ集合 集合选择器(&quot;div,#box,p&quot;)获取的是JQ集合 2.层次选择器后代选择器$(&quot;#box p&quot;) 获取的是JQ集合 子代选择器$(&quot;#box&gt;p&quot;)获取的是JQ集合 弟弟选择器下一个弟弟选择器 $(&quot;#box+&quot;)获取的是一个jQ对象 $(&quot;#box+div&quot;)获取的是一个jQ对象(表示#box的第一个是div的弟弟)所有的弟弟 $(&quot;#box~&quot;)获取所有的弟弟,是一个jQ集合 $(&quot;#box~div&quot;)获取所有标签名为div的弟弟,是一个集合 3.基本过滤选择器:first(获取第一个元素) $(&quot;div :first&quot;)表示选取div中的第一个孩子元素,如果第一个div中没有,就去第二个div中找 $(&quot;div:first&quot;)所有div中的第一个div:last(获取最后一个元素)$(&quot;div:last&quot;)所有div中的最后一个div:not(去除所有与给定选择器匹配的元素)$(&quot;div:not(.box)&quot;)class名不是box的所有div:odd(奇数)$(&quot;div:odd&quot;)索引是奇数的集合:odd(偶数)$(&quot;div:even&quot;)索引是偶数的集合:eq(索引)$(&quot;div:eq(1)&quot;)选取索引为1的div:gt$(&quot;div:gt(2)&quot;)选取索引大于2的div:lt$(&quot;div:lt(2)&quot;)选取索引小于2的div:header 选取所有的h(h1-h6)标签$(&quot;.box :header&quot;)类名是box的元素中所有h标签 :animated选取所有进行动画的标签(js动画,css3动画不行) 注意:表示是指定容器下的必须加空格 4.内容过滤选择器:contains(“内容”) $(&quot;div:contains(&#39;我&#39;)&quot;)所有的div中含有内容是”我”的div标签,选取的是一个jQ集合 :has() $(&quot;div:has(p)&quot;)所有包含p标签的div,选取的是一个jQ集合 :empty空元素集合:parent非空集合5.可见性过滤选择器:hidden 隐藏元素display:none或者type=”hidden”匹配所有不可见元素,或者type为hidden的元素 :visible 可见元素6.属性过滤选择器 $(&quot;div[id]&quot;)所有 有id名的div $(&quot;div[class=box]&quot;)所有class=box的div $(&quot;div[class!=box]&quot;)所有class!=box的div $(&quot;div[class^=box]&quot;)所有class以box开头的div $(&quot;div[class$=box]&quot;)所有class以box结尾的div $(&quot;div[class*=box]&quot;)所有class含有box的div $(&quot;div[class|=box]&quot;)所有class=box或者以box-作为前缀的div $(&quot;div[class~=box]&quot;)所有class以空格分开后的class名中真的含有box这个类名的div7.子元素过滤选择器 :nth-child(1) 第一个孩子 1$("div p:nth-child(1)"); :nth-child(odd) 所有奇数个的孩子 :nth-child(even) 所有偶数个的孩子 :nth-child(3n)n从1开始,所有是3的倍数的孩子; :first-child 第一个孩子 :last-child 最后一个孩子表单对象属性过滤器12345678910111213&lt;form id="form1" action="" method="post"&gt; &lt;input type="text" name="" value="输入框" disabled="disabled"/&gt; &lt;input type="submit" value="提交按钮" disabled="disabled"/&gt; &lt;input type="checkbox" name="" value="复选框" /&gt; &lt;input type="button" name="" value="按钮" /&gt; &lt;input type="file" name="" value="获取文件" /&gt; &lt;input type="password" name="" value="" /&gt; &lt;radio&gt;&lt;/radio&gt; &lt;select name=""&gt; &lt;option value="1"&gt;1&lt;/option&gt; &lt;option value="2"&gt;2&lt;/option&gt; &lt;/select&gt;&lt;/form&gt; $(&quot;#form1 :enabled&quot;);选取form1下面的所有可用元素$(&quot;#form1 :disabled&quot;);选取form1下面的所有不可用元素$(&quot;#form1 :checked&quot;);选出form1下所有被选中的元素$(&quot;#form1 select option:selected&quot;);下拉选项被选中的元素$(&quot;#form1 :input&quot;);input /textarea /select /button$(&quot;:text&quot;);所有的单行文本框$(&quot;:password&quot;);所有的密码框$(&quot;:radio&quot;);所有的单选框$(&quot;:checkbox&quot;);所有的复选框$(&quot;:submit&quot;);所有的提交按钮$(&quot;:image&quot;);所有的图片按钮$(&quot;:button&quot;);所有的按钮$(&quot;:reset&quot;);所有的重置按钮$(&quot;:file&quot;);所有的上传域$(&quot;:hidden&quot;);所有隐藏元素]]></content>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MongoDB]]></title>
    <url>%2F2017%2F03%2F11%2FMongoDB%2F</url>
    <content type="text"><![CDATA[mongodb的特点 开源 免费 性能高(非关系数据库) 分布式 并发量 数据量 操作语言: javascript 缺点: 有可能丢失数据,所以安全性不是非常高 分布式是指将不同的业务分布在不同的地方。 而集群指的是将几台服务器集中在一起，实现同一业务。 数据库开启与关闭 开启 客户端 mongo 输入db检测连接是否成功 数据库端mongod --dbpath=D:\Mongodb\data (D:\Mongodb\data自己创建的存储数据的空目录);如果出现waiting for connections on port 27017就表示启动成功,已经在27017端口上监听了客户端的请求 注意：–dbpath后的值表示数据库文件的存储路径,而且后面的路径必须事先创建好，必须已经存在，否则服务开启失败 关掉数据库 use admin;db.shutdownServer(); mongoose Mongoose是MongoDB的一个对象模型工具 同时它也是针对MongoDB操作的一个对象模型库,封装了MongoDB对文档的一些增删改查等常用方法 让NodeJS操作Mongodb数据库变得更加灵活简单 安装mongoose$ npm install mongoose 使用步骤 1) 引入mongoose模块: let mongoose=require(&quot;mongoose&quot;) 2) 返回连接对象: let coon =mongoose.createConnection(&#39;mongodb://127.0.0.1/201704node&#39;)(格式:monogdb://IP:端口号/数据库名称); 3) 创建数据库的骨架模型，规定集合文档中的字段名称和字段类型 12345//这就是规定了集合中文档的名称为name age,类型分别是字符串和数字let UserSchema = new mongoose.Schema(&#123; name:String,//用户名称 age:Number//用户年龄&#125;); 4) 定义模型 2个参数表示定义一个模块 1个参数表示获取一个模型 1let User = conn.model('User',UserSchema); 增删改查增 create12345678910User.create(&#123;name:'zfpx',age:"300"&#125;,function(err,doc)&#123; if(err)&#123; console.error(err); &#125;else&#123; //__v: 0 版本号，解决并发问题 //_id 是文档的主键, 1.唯一的 2 没什么太多业务含义，所以永远不需要修改 //&#123; __v: 0, name: 'zfpx', age: 8, _id: 5972c54c4735381708af182d &#125; console.log(doc); &#125;&#125;); 删remove参数1{age:300}是文档对象,可以是一个数组，就是条件,默认情况下回删除掉符合条件的所有的文档,不同的模型对应于不同的集合 12345678User.remove(&#123;age:300&#125;,function(err,result)&#123; if(err)&#123; console.log(err); &#125;else&#123; //&#123; ok: 1, n: 0 &#125; ok=1表示删除操作成功 n=0表示实际删除掉的条数为0 console.log(result.result); &#125;&#125;); 改 update1参数1是更新的条件 参数2是更新后的值 1234567//$inc = increment 增加 在原来字段的基础上加1User.update(&#123;_id:'5972cc94f3ef0e1580666fa6'&#125;,&#123;$inc:&#123;age:5&#125;&#125;,function(err,result)&#123; //&#123; ok: 1, nModified: 1, n: 1 &#125; // 更新成功 实际修改的条数1 符合更新条件的条数 //如果更新前的值和更新后的值是一样的话，那么不进行实际更新 console.log(result);&#125;); 查 find123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960//参数1里放的是条件//参数2里放的是要显示或排除显示的字段 &#123;字段名:1&#125;表示只显示此字段// &#123;字段名:0&#125; 表示只排除显示指定的字段// 只显示name 只排除age home//Can't canonicalize query: BadValue Projection cannot have a mix of inclusion and exclusion.//0 exclusion 非0 inclusion//两个条件的或 $orUser.find(&#123;$or:[&#123;name:"zfpx1"&#125;,&#123;name:"zfpx2"&#125;]&#125;,function (err,result) &#123; console.log(result); &#125;) // age &gt;2 &lt;2 &gt;=2 &lt;=2// age $gt $lt $gte $lteUser.find(&#123;age:&#123;$gt:5&#125;&#125;,function (err,result) &#123; console.log(result); &#125;) // 模糊匹配User.find(&#123;name:/zfpx/&#125;,function (err,result) &#123; console.log(result); &#125;) //findOne let username=1, password=2;User.findOne(&#123;username,password&#125;,function (err,doc) &#123; //最多只返回一条 只要查找到符合条件的记录就返回不再继续查询; //doc返回null,或者是一个文档对象; if(err)&#123; console.log(err); &#125;else&#123; console.log(doc); if(doc)&#123; console.log(doc); console.log("登陆成功"); &#125; &#125;&#125;)//findByIdUser.findById('5972cc94f3ef0e1580666fa6',&#123;name:1&#125;,function(err,doc)&#123; &#123; _id: 5972cc94f3ef0e1580666fa6, name: 'zfpx1', age: 112, __v: 0 &#125; console.log(doc);&#125;);let pageNum=2;//当前页码let pageSize = 3;//每页的条数//skip跳过指定的条数//limit指定返回的最多条数//DeprecationWarning: Mongoose: mpromise (mongoose's default promise library) is deprecated, plug in your own promise library instead//sort指定排序的字段 age:-1 表示降序 1表示升序//只有在调用exec的时候 才会真正向服务器发起查询User.find() .limit(pageSize) .sort(&#123;age:1&#125;) .skip((pageNum-1)*pageSize) .exec(function(err,docs)&#123; console.log(docs); &#125;)]]></content>
      <tags>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[import和export]]></title>
    <url>%2F2016%2F10%2F11%2Fimport%20%E5%92%8Cexport%2F</url>
    <content type="text"><![CDATA[ES6中的模块一个单独的文件就是一个模块。每一个模块都是一个单独的作用域，在一个文件中定义的变量，都是私有的，对其他文件是不可见的。 import 和export是ES6中的模块处理方法 export 用于对外输出本模块(一个文件可以理解为一个模块)变量的接口 import 用于在一个模块中加载另一个含有export接口的模块 也就是说使用export命令定义了模块的对外接口以后,其他js文件就可以通过import命令加载这个模块(文件) 举个例子: 假设在同一个目录下有两个文件a.js和b.js 123456789// a.jsvar sex="boy";var echo=function(value)&#123; console.log(value)&#125;export &#123;sex,echo&#125; //通过向大括号中添加sex，echo变量并且export输出，就可以将对应变量值以sex、echo变量标识符形式暴露给其他文件而被读取到//不能写成export sex这样的方式，如果这样就相当于export "boy",外部文件就获取不到该文件的内部变量sex的值，因为没有对外输出变量接口,只是输出的字符串。 12345// b.js通过import获取a.js文件的内部变量，&#123;&#125;括号内的变量来自于a.js文件export出的变量标识符。import &#123;sex,echo&#125; from "./a.js" console.log(sex) // boyecho(sex) // boy 通过上面的例子可以看出,b.js使用import命令的时候,用户需要知道a.js所暴露出的变量标识符,否则无法加载,可以使用export default命令,为模板指定默认输出,这样就不需要知道所要加载模块的变量名 如下: 12345//a.jsvar sex="boy";export default sex（sex不能加大括号）//原本直接export sex外部是无法识别的，加上default就可以了.但是一个文件内最多只能有一个export default。其实此处相当于为sex变量值"boy"起了一个系统默认的变量名default，自然default只能有一个值，所以一个文件内不能有多个export default。 12345// b.js本质上，a.js文件的export default输出一个叫做default的变量，然后系统允许你为它取任意名字。所以可以为import的模块起任何变量名，且不需要用大括号包含import any from "./a.js"import any12 from "./a.js" console.log(any,any12) // boy,boy]]></content>
      <tags>
        <tag>module</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[canvas基础]]></title>
    <url>%2F2016%2F07%2F26%2Fcanvas%2F</url>
    <content type="text"><![CDATA[概述canvas 是h5新标签,在页面上绘制图形用的(通常称为画布),canvas只是一个容器,我们用js脚本来进行控制和操作 获取canvas:在js中对canvas进行操作标签之前和其他的标签元素一样要先获取出来var draw=document.getElementById(&quot;draw&quot;); 设置绘制环境:getContext(“2d”);2d表示在平面上进行绘制var cvs=draw.getContext(&quot;2d&quot;); 绘制图形的两种方式: 边框：cvs.stroke() cvs.strokeStyle=”笔触颜色(边框的颜色)” cvs.lineWidth=数值,边框的宽度 填充:cvs.fill(); cvs.fillStyle=”填充的样式”; 支持的颜色书写方式 颜色的名字 red yellow 十六进制 三色值:rgb(123,234,120) 四色值:rgba(123,234,120,.5);功能操作绘制线条 cvs.moveTo(x,y) 起始点的坐标, cvs.lineTo(x,y) 结束点的坐标 如果没有moveTo就把上一个挨着的lineTo作为起始坐标 cvs.beginPath()开始一个新的路径 cvs.closePath();关闭当前路径,自动闭合,从结束的坐标到起始坐标自动连接设置线条交汇处的样式css中的圆角border-radius,canvas中也可以实现这个效果lineJoincvs.lineJoin=”属性值”,他有三个属性值 尖角miter 圆角round 斜角bevellineCapcvs.lineCap=”属性值”,他有三个属性值 butt(默认的,平的), round(圆角), square(方角) 注意: 对于单个线条,一旦加上关上当前路径(closePath)就没有圆角的效果了; 绘制矩形cvs.fillRect(x,y,w,h);填充的矩形 x,y是这个矩形左上角的坐标 w,h这个矩形的宽和高 注意:边框一半在里面,一半在外面; 绘制矩形的两种方式: cvs.fillRect(10,20,100,50); cvs.strokeRect(150,20,100,50);123456789101112function draw1()&#123; //填充方式 cvs.fillStyle="rgba(0,0,190,.5)"; cvs.fillRect(10,20,100,50); //边框方式 cvs.strokeStyle="rgba(190,0,0,.5)"; cvs.lineWidth=30; cvs.strokeRect(150,20,100,50); //边框一半在里面,一半在外面,所以实际的坐标是165,35 &#125;draw1(); 清除某部分格式:cvs.clearRect(x,y,w,h); x:left值 y:top值 w:width h:height 绘制圆格式:cvs.arc(x,y,r,s,e,n) x,y是圆心的坐标, r是半径, s起始角,以弧度计算(三点钟方向是0度), e结束角, n:是否逆时针true/false(默认是false顺时针); 注意:每次调用fill的时候,会把当次路径的起始点和结束点分别连接,填充闭合部分,所以以后每次再写路径的时候记得关闭当前路径 渐变线性渐变格式:var CLG=cvs.createLinearGradient(x0,y0,x1,y1);CLG.addColorStop(n,m) x0:渐变开始的x坐标 y0:渐变开始的y坐标 x1:渐变结束的x坐标 y1:渐变结束的y坐标 n:设置颜色的偏移量 m:颜色123456789101112131415function draw1()&#123; var CLG=cvs.createLinearGradient(0,0,200,200); CLG.addColorStop(0,"white"); CLG.addColorStop(0.15,"pink"); CLG.addColorStop(0.25,"white"); CLG.addColorStop(0.5,"skyblue"); CLG.addColorStop(0.6,"white"); CLG.addColorStop(0.75,"pink"); CLG.addColorStop(1,"white"); cvs.fillStyle=CLG; cvs.fillRect(0,0,200,200); &#125;draw1(); 径向渐变(发散性渐变)格式：cvs.createRadialGradient(x0,y0,r0,x1,y1,r1) x0:渐变开始的x坐标 y0:渐变开始的y坐标 r0:渐变开始的半径 x1:渐变结束的x坐标 y1:渐变结束的y坐标 r1:渐变结束的半径12345678910111213unction draw2()&#123; var CRG=cvs.createRadialGradient(480,480,30,350,350,680); CRG.addColorStop(0,"white"); CRG.addColorStop(0.15,"pink"); CRG.addColorStop(0.25,"white"); CRG.addColorStop(0.5,"skyblue"); CRG.addColorStop(0.6,"white"); CRG.addColorStop(0.75,"pink"); CRG.addColorStop(1,"white"); cvs.fillStyle=CRG; cvs.fillRect(100,100,400,400);&#125;draw2(); 绘图格式一cvs.drawImage(Image,x,y,w,h); Image:就是可以放在DOM中的真实图片,可以动态创建,也可以获取页面上的 x,y 图片左上角的坐标 w,h绘制图片的宽高12345678function draw1()&#123; var img=new Image; img.src="QQ图片20170608163047.gif"; img.onload=function()&#123; cvs.drawImage(this,0,100,100,75) &#125; &#125;draw1(); 格式二(可截取)cvs.drawImage(Image,sx,sy,sw,sh,dx,dy,dw,dh) sx,sy 图片左上角的坐标 sw,sh 矩形区域的宽高,用来截取图片; dx,dy 截取出来放在canvas上的坐标 dw,dh 画在canvas上的宽高; sx,sy,sw,sh是截取图片的过程 dx,dy,dw,dh是把截取出来的图片放在canvas上的过程;123456789function draw2()&#123; var img= new Image; img.src="2.jpg" img.onload=function()&#123; cvs.drawImage(this,480,150,440,410,0,0,100,100) cvs.createPattern(this,"repeat-x") &#125; &#125;draw2(); 设置平铺格式：cvs.createPattern(Image,type); Image:就是可以放在DOM中的真实图片,可以动态创建,也可以获取页面上的 type:no-repeat不平铺,repeat全方向平铺, repeat-x:x轴方向平铺 repeat-y:y轴方向平铺1234567891011function draw3()&#123; var img= new Image; img.src="../imges/chimpified.jpeg" img.onload=function()&#123; var rep=cvs.createPattern(this,"repeat"); cvs.fillStyle=rep; cvs.fillRect(0,0,draw.width,draw.height); &#125;&#125;draw3(); 变形平移格式：cvs.translate(x,y) x:坐标原点向x轴平移的距离 y:坐标原点向y轴平移的距离缩放格式：cvs.scale(x0,y0); x0:x轴照x0的比例缩放 x0:y轴照y0的比例缩放 旋转格式：cvs.rotate(angle); angle:坐标轴转的角度(跟画圆的弧度计算是一样的) 综合案例123456789function draw2()&#123; cvs.translate(140,0) cvs.rotate(Math.PI/2); cvs.translate(0,-70); cvs.scale(0.6,1.1); cvs.fillStyle="greenyellow"; cvs.fillRect(100,20,200,70); &#125;draw2(); 字体绘制文本 1)设置字体样式：cvs.font=&quot;字体大小font-size font-family&quot; 2）对齐方式 水平对齐：cvs.textAlign(属性值:start,end,right,center) 垂直对齐齐：cvs.textBaseline=&quot;一个值&quot;(属值:&quot;top&quot;,middle,hanging,bottom,alphabetic,ideographic) 3) cvs.measureText()计算文本长度(可以理解为文本的宽度，返回值是一个对象) 4） 填充文字cvs.fillText(text,x,y); 绘制文字轮廓cvs.strokeText(text,x,y) text:文本内容 x,y:文字起始点的坐标12345678910111213function draw2()&#123; var text="hello world"; cvs.fillStyle="#FFA500"; cvs.font="40px verdana"; cvs.textAlign="start"; cvs.textBaseline="top"; cvs.fillText(text,0,0); var length=cvs.measureText(text); console.dir(length); cvs.fillText("字体长度为"+length.width,0,50); &#125; draw2(); 阴影 cvs.shadowOffsetX;阴影横向偏移量(默认值是0); cvs.shadowOffsetY;阴影的纵向偏移量(默认值是0); cvs.shadowColor;阴影的颜色 cvs.shadowBlur阴影的模糊范围(值越大越模糊) 附一个漂亮字体的综合案例123456789101112131415161718192021222324function draw3()&#123; var CLG=cvs.createLinearGradient(0,150,450,250); //设置渐变的颜色 CLG.addColorStop(0,"pink"); CLG.addColorStop(0.15,"skyblue"); CLG.addColorStop(0.2,"orange"); CLG.addColorStop(0.5,"pink"); CLG.addColorStop(0.75,"skyblue"); CLG.addColorStop(1,"pink"); var text="哈哈~~"; cvs.fillStyle=CLG; //设置阴影 cvs.shadowOffsetX=5; cvs.shadowOffsetY=4; cvs.shadowColor="#87CEEB";//阴影颜色 cvs.shadowBlur=5;//阴影模糊范围 cvs.font="40px cursive";//字体设置 cvs.textAlign="start";//水平对齐 cvs.textBaseline="top";//垂直对齐 cvs.fillText(text,20,120);//导入文字 var wid=cvs.measureText(text).width; //获取文字长度这个对象中的width属性的值 cvs.fillText("hahahahah"+wid,20,30); &#125;draw3(); 图形组合交叠样式格式：cvs.globalCompositeOperation=typetype的值：1.source-over:默认值 在原来的图形上绘制新图(覆盖的意思);2.destination-over:在原来的图形下面绘制新图;3.source-in:显示交集颜色是新图的颜色;4.destination-in:显示交集,颜色是旧图的颜色;5.source-out:显示新图非交集部分6.destination-out:显示旧图非交集部分7.source-atop:显示旧图和交集部分,交集是新图的颜色;8.destination-atop:显示新图和交集部分,交集是旧图的颜色;9.lighter:全部显示,交集部分是颜色的叠加10.xor:显示新旧图的非交集部分11.copy:只显示新图12345678function draw1()&#123; cvs.fillStyle="rgb(250,0,250)"; cvs.fillRect(10,10,100,100); cvs.globalCompositeOperation="lighter"; cvs.fillStyle="#449FDB"; cvs.fillRect(50,50,200,200) &#125; draw1();]]></content>
      <tags>
        <tag>html5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BOM]]></title>
    <url>%2F2016%2F06%2F30%2Fwindow%E5%92%8Cdocument%2F</url>
    <content type="text"><![CDATA[BOM浏览器对象模型在JavaScript中对象之间并不是独立存在的，对象与对象之间有着层次关系。浏览器对象模型就是用于描述这种对象与对象之间层次关系的模型，该对象模型提供了独立于内容的、可以与浏览器窗口进行互动的对象结构。BOM由多个对象组成，其中代表浏览器窗口的Window对象是BOM的顶层对象，其他对象都是该对象的子对象。在Window对象之下有下述几个子对象。 Document对象该对象代表浏览器窗口中所加载的文档。使用Document对象可以操作文档中的内容。在整个BOM中，只有Document对象是与HTML文档的内容相关的。 Frames数组：该数组代表浏览器窗口中的框架。HTML中允许将一个浏览器窗口分为多个框架，每个框架中可以加载一个HTML文档。在这种框架页中，每一个框架都是Frames数组中的一个元素。而Frames数组中的每一个元素都是一个Window对象。 History对象该对象代表当前浏览器窗口的浏览历史。通过该对象可以将当前浏览器窗口中的文档前进或后退到某一个已经访问过的URL（统一资源定位符）。 Location对象该对象代表当前文档的URL。URL分为几个部分，如协议部分、主机部分、端口部分等。使用Location对象可以分别获得这些部分，并且可以通过修改这些部分的值来加载一个新文档。 Navigator对象该对象是浏览器对象，代表了浏览器的信息。该对象与Window对象不同，Window对象可以用于控制浏览器窗口的一些属性，如浏览器窗口大小、位置等。而Navigator对象包含的是浏览器的信息，如浏览器的名称、版本号等。 Screen对象该对象代表当前显示器的信息。使用Screen对象可以获得用户显示器的分辨率、可用颜色数量等信息。 Document对象代表HTML文档，而HTML文档中包括了有很多元素，BOM也将这些元素看成了不同的对象。从图12-2中可以看出，Document对象还有下述几个子对象。 Anchors数组该数组代表了文档中的所有锚。数组中的每一个元素都是一个锚对象。每一个锚对象都对应着HTML文档中的一个包含name属性的标签，通过锚对象可以获得锚的命名，以及超链接中的文字。 Applets数组该数组代表了嵌在网页中的所有小程序。数组中的每一个元素都是一个Applet对象，通过Applet对象可以获得Java小程序的公有字段。 Embeds数组与Applets类似，但建议使用Embeds数组。 Forms数组该数组代表文档中 的所有表单。数组中的每一个元素都是一个Form对象。每一个Form对象都对应着HTML文档中的一个标签。通过Form对象可以获得表单中的各种信息，也可以提交或重置表单。由于表单中还包括了很多表单元素，因此，Form对象的子对象还可以对这些表单元素进行引用，以完成更具体的应用。 Images数组该数组代表文档中的所有图片。数组中的每一个元素都是一个Image对象。每一个Image对象都对应着HTML文档中的一个标签。通过Image对象可以获得图片的各种信息。 Links数组该数组代表文档中的所有超链接。数组中的每一个元素都是一个Link对象。每一个Link对象都对应着HTML文档中的一个包含href属性的标签，通过Link对象可以获得超链接中URL的各部分信息。 Location对象该对象与Window对象中的Location对象完全相同。由于该对象与HTML文档并没有太大关系，因此，该对象是反对使用的对象，建议使用Window对象的Location子对象。 BOM并不是W3C中的标准，因此，不同的浏览器所支持的BOM中的对象、对象的属性和方法都有可能不同。从图12-2中可以看出，Document对象下有很多子对象，因此Document对象是一个十分重要的对象。事实上，大多数浏览器都支持Document对象。在W3C正式定义DOM之前，BOM中的Document分支就已经被众多浏览器支持。DOM被正式定义之后，分为了三个层次，分别为1级DOM（DOM Level 1）、2级DOM（DOM Level 2）和3级DOM（DOM Level 3）。而BOM中的Document分支被称为0级DOM（DOM Level 0），因为该分支定义了文档功能的基本功能。]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP事务]]></title>
    <url>%2F2016%2F05%2F02%2Fhttp%E4%BA%8B%E5%8A%A1%2Bajax%2F</url>
    <content type="text"><![CDATA[组成 request 请求阶段:客户端向服务器发送请求 response响应阶段:服务器把数据返回给客户端 客户端和服务器端进行内容的传输,这个过程是由传输协议来完成的–&gt;&gt;http HTTP报文客户端和服务器端传输的内容统称为HTTP报文,报文中详细的内容在谷歌控制台中的NetWork里可以详细的看到 起始行:http报文第一行,在请求报文中用来说明做些什么,在响应报文中说明出现了什么情况 请求起始行 响应起始行 header:首部 request headers 请求头,客户端设置,服务器获取,一般在真实的项目中我们会把一些内容放在请求头里面传给服务器,例如:客户端可以把一些cookie的信息传给服务器; 设置请求头之前必须保证已经执行OPEN了 1234//编码和解码格式:如果想用汉字,就需要相应的客户端编码和服务器解码//1.escape/unescape:客户端对中文或者是特殊字符进行编码,服务器进行解码,但是一般不用,因为只有node环境才支持,//encodeURI/decodeURI:按照UNICODE编码解码,只对汉字进行编码/解码//3.encodeURIComponent/decodeURIComponent:可以把特殊字符和汉字进行编码/解码 response headers 响应头,服务器设置,客户端获取,比如我们之前写的返回数据的类型,加在响应头中,获取服务器的时间,这个事件就是响应头中的时间; 主体 请求主体:客户端设置,服务器获取,一般把客户端向服务器传输的数据都放在请求主体里面 send(数据) 响应主体:服务器返回给客户端的数据都写在响应主体中,response.end(这里面的东西就是响应主体) AJAX是什么?AJAX是 Async(异步) Javescript And XML的缩写,是客户端js中的方法,用来向服务器端发送请求(还可以传递给服务器端数据 ),然后把服务器端返回的内容获取到(ajax一般是运行在客户端的浏览器中的); xml:可扩展的标记语言(在xml文件中使用的标签都是自己扩展的)–&gt;&gt;利用自己扩展的有规则的标记来存储相关的数据 异步:客户端和服务器数据交互不需要整个页面刷新,只需要将操作的这一部分更新一下,这就叫做局部刷新; AJAX一般都是用来请求页面的部分数据,再将获取出来的数据绑定到页面的指定位置 如何使用四步: 1)创建一个ajax的异步对象var xhr=new XMLHHTTPRequest(这种方式不兼容IE6及更低版本的浏览器,需要做兼容处理) 2)打开一个URL地址并请求(发送请求之前的配置) open([请求方式],[API接口],[设置同步异步],[user name],[user pass]) [请求方式]: get系列:get/delete/head post系列:post/put [user name]:用户名 [user pass]:用户密码 有些服务器为了安全考虑,只允许部分人可以访问,就只给部分人分配权限,访问的时候需要提供安全密钥,一般的服务器不需要这么麻烦,匿名访问即可,所以只需要传前三个参数即可; 3)监听不同的状态进行不同的业务操作 onreadystatechange xhr.readyState:Ajax状态码,可以代表当前ajax处理的进度; 0:unsend 未发送,刚开始创建一个AJAX的实例,var xhr=new XMLHHTTPRequest;(请求阶段) 1:open url地址已经打开(发送前的参数配置已经完成),第二步open(“get”,url,true);(请求阶段) 2:headers_received 客户端已经接收响应头(响应阶段,此时的响应头里包含了发送响应头的服务器时间) 3:loading 服务器返回的响应主体正在传输(响应阶段) 4:done 服务器返回的响应主体已经被客户端接收;(响应阶段) xhr.status HTTP网络状态码 http响应报文返回时都会携带一个状态码,通过这个状态码可以知道HTTP事务是否成功,以及失败的原因 [2开头]:只要是2开头的就代表成功,比如:200:ok [3开头]:也代表成功,只不过这个过程经过了特殊处理 301:Moved Permanently 在新版的HTTP协议中代表永久重定向,比如访问http://www.360buy.com默认会跳转到京东 http://www.jd.com 302:Moved temporarily 在新版的HTTP协议中代表临时转移(也叫临时重定向) –&gt;服务器的负载均衡 304:Not Modified()获取的是缓存中的数据(网站性能优化的重要手段,我们一般将一些不怎么变的静态资源js/css/img等 做成304缓存 以后直接从缓存中拿就可以了 ) [4开头] 代表错误,而且一般都是客户端的错误 400: Bad Request 请求参数出错了 401:Unauthorized 无访问权限 403:请求接收到了,但是没有返回正常的结果,而且没有原因 404:Not Found 请求地址不存在 413:客户端传给服务器的内容超过了服务器愿意接收的范围 [5开头] 代表服务器错误 500: Iternal Server Error 服务器的未知错误 503: Server UNavailable服务器超负荷 xhr.response: 获取响应主体(一般不用) xhr.responseText:获取响应主体的内容(是text字符串格式的) xhr.responseXML:获取响应主体的内容,但是是XML格式的 xhr.getResponseHeader:获取响应头 xhr.getAllResponseHeaders:获取所有的响应头 xhr.timeout: 设置请求的超时时间,比如设置的是3s,超过3s就算请求失败,并且如果请求超时就会触发一个 ontimeout事件 xhr.abort():中断当前的AJAX请求,而且 一旦中断请求就会触发onabort事件 xhr.setrRequestHeader([属性名],[属性值]):设置请求头信息 4)发送send():AJAX这件事是从send开始的之前的步骤都是在做准备工作,当我们的xhr.readyState==4的时候结束 GET和POST的区别 get系列与post系列的不同 1) 传参数的方式不同:get方式是通过问号传参(url+?+参数), post: xhr.send(给后台发送的数据,是字符串); 2) get方式容易出现缓存(可以通过加一个时间戳来解决缓存问题), 出现缓存的原因是GET是通过url上问号拼接参数的形式给服务器传参数的,如果当前传的参数跟上一次的一样了,浏览器就会走他的记忆功能(缓存),以为你请求的是同一个url,就会把之前返回给你,这样有些需求是不可以的. 比如我想实时获取股票信息,就不能走缓存. 而post不会 3)参数大小:get方法限制大小,get是将数据直接拼接在url后端query部分,而浏览器对url的长度有限制,所以get有大小限制,post没有大小限制.因为post是将数据放在请求的主体里,而主体是不限制大小的,所以没有大小的限制(但是我们一般不会让他大于100kb);(chrome是8kb firefox是7kb ie是2kb) 4)安全性: get可以看到发送给服务器的数据,因为他是放在url上的, 而post不会被看到,因为post把数据放到主体里了 ,一般有重要的信息都会采用post请求 5)功能: get主要是用来从服务器拉取数据,而post主要是用来将数据发送到服务器]]></content>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS3选择器]]></title>
    <url>%2F2016%2F04%2F26%2FCSS3%2F</url>
    <content type="text"><![CDATA[1.动态伪类选择器 a:hover 鼠标放上 :focus 获取焦点一般用在表单元素上 a:active 鼠标点一下 a:visited 链接访问过一般用在锚点 a:link 链接未被访问过 一般用在锚点 2.UI伪类选择器 input:disabled(禁用) input:enabled(可用) input:checked(被选中的)3.结构伪类选择器 div :first-child选择第一个子元素 div :last-child最后一个子元素 nth-child(2) nth-child(n) n是整数以1开始 nth-child(even)所有偶数 nth-child(odd)所有奇数 nth-last-child(1)倒着数 nth-of-type(2)同类型的第几个 nth-last-of-type倒着数 first-of-type同类型的第一个 last-of-type同类型的最后一个 only:child父级只有他一个孩子 div:empty没有任何内容的div4.伪元素选择器(:也可以用::) :after :before first-line首行 first-letter首字母]]></content>
      <tags>
        <tag>CSS3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[静态资源文件请求的处理]]></title>
    <url>%2F2016%2F01%2F03%2F%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E6%96%87%E4%BB%B6%E8%AF%B7%E6%B1%82%E7%9A%84%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[带后缀名的都是静态资源文件,请求静态资源–&gt;前端路由 MIME类型每一种资源文件都有自己的标识类型 html–&gt;&gt;text/html css–&gt;&gt;text/css js–&gt;&gt;text/javascript txt–&gt;&gt;text/plain json–&gt;application/json ​ 浏览器会按照代码的MIME类型进行渲染,所以要根据请求文件的后缀名获取当前文件的MIME类型,让服务器按照指定的目录读取文件中的内容或者代码(读取出来的内容都是字符串格式的),返回给客户端的也应当是字符串格式的文件 重写响应头信息告诉浏览器返回的内容是什么养的MIME类型 response.writeHead(200,{“content-type”:pathname+”;charset=utf-8;”})]]></content>
      <tags>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node之buffer]]></title>
    <url>%2F2016%2F01%2F02%2Fnode%E7%AC%AC%E4%BA%8C%E5%A4%A9%2F</url>
    <content type="text"><![CDATA[发布订阅模式 on emit 订阅 维护关系的 ,一对多的关系 发布 找到一对多的关系,让绑定的事情一次触发 主要依赖的就是回调函数 buffer buffer代表的是内存 node为了操作二进制生产出来的一个类型,buffer默认展示成16进制,可以和字符串无条件转换 2进制,16进制 字符串在node中只支持utf-8的格式 一个汉字utf-8有几个字节–&gt;&gt;3个字节 比字节小的单位 1个字节由8个位组成, 二进制转10进制: 当前的最大值*二进制(当前第几位-1)累加求和]]></content>
      <categories>
        <category>进阶中</category>
      </categories>
      <tags>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node基础二]]></title>
    <url>%2F2016%2F01%2F01%2Fnode%E7%AC%AC%E4%B8%80%E5%A4%A9%2F</url>
    <content type="text"><![CDATA[怎么解决异步问题? callback 123456789let read=(cb)=&gt;&#123; setTimeout(()=&gt;&#123; let str="wohenmei"; cb(str); &#125;,2000)&#125;read(function (data) &#123; console.log(data);&#125;);//解决异步问题,可以输出str node环境下的js不具有兼容性在node中能用异步绝不用同步123//解决异步问题,将后续的逻辑当做参数传递给这个函数--&gt;&gt;callback;//异步永远在同步之后执行,如果同步执行不能完成,异步永远不会触发//非阻塞是异步的前置条件 单线程 多线程–&gt;&gt;node是基于js(单进程–&gt;&gt;并且单线程)的 node(底层是c) 单线程 异步 js中的多线程(h5)–&gt;&gt;如果想开多线程–&gt;&gt;要开子进程(这个子进程可以有多线程) 多线程–&gt;&gt;感觉像同一时间干很多事,实际上只是快速的切换上下文 js中的模块化 js中实现模块化–&gt;&gt;单例,闭包 单例,缺点:不能保证一定不冲突,会导致调用过长,require(AMD),seajs(CMD),import,export,不兼容 没有块级作用域 node 自带模块化 commonjs规范 怎么定义一个 模块(每个js都是一个模块,在每个文件外面自动增加一个闭包) 如何导出一个模块module.exports/exports; 如何引用一个模块 require(); exports,module,require, __dirname ,__filename,都是这个文件外层套了一个闭包,闭包中的形参,这五个也是全局变量 123(function()&#123; &#125;)(exports,module,require,__dirname,__filename) 模块分类文件模块 暴露的实现原理 12345 (function()&#123; module.exports=exports=&#123;&#125;;//所以不能直接更改exports,用exports=obj的形式导出想要的方法,因为export被重新赋值了,与module.exports的连接断了 //this--&gt;&gt;module.exports; return module.exports;&#125;)() 三种暴露方式(特别注意返回值是module.exports) 1)module.exports=sum–&gt;&gt;sum是要暴露出的函数 2)module. exports.sum=sum 3)exports.sum=sum 第三方模块 全局安装(只能在命令行下使用) node切换源的工具 npm install nrm -g nrm ls–&gt;&gt;源列表 nrm test(测试源) nrm use cnpm 本地安装 (在当前项目下使用) npm init 生成记录所有依赖的package.json,否则会安装到上级目录,名字不能有中文不能有大写,和特殊字符 开发依赖 只在开发时应用–save-dev(简写–&gt;&gt;-D) 项目依赖 开发上线都需要–save(简写–&gt;&gt;-S) 安装 npm install 卸载npm uninstall 模块的名字 查看模块版本 npm info vue 指定版本安装 npm install vue@1.0.0 –save 引用 直接require(模块名称),不需要./或../,在node_modules下查找,当前目录下没有回去上级查找,找到根盘符为止 module.paths 查找的顺序 yarn 需要npm来下载(主流) 安装一次即可 1npm install yarn -g yarn init -y 本地安装 开发依赖yarn add less –dev 项目依赖 yarn add jquery 删除 yarn remove less –dev 安装全部依赖yarn install 发布包(必须得是别人没发过的,包里需要一个package.json文件) 需要登录到官方npm上 注册账号 npm assUser npm node package manager 管理node的包(很多js文件)的,安装node自带npm 内置模块(核心模块)–&gt;&gt;node自带的]]></content>
      <tags>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node基础二]]></title>
    <url>%2F2016%2F01%2F01%2F%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%92%8C%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E4%BA%A4%E4%BA%92%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[交互模型图 客户端:用户自己电脑的浏览器 服务器端:浏览项目所在的服务器 服务器的端口号:属于服务器,一台服务器上可以发布很多的项目,而每一个项目都有自己对应的房间或区域,服务器使用端口号来区分具体是哪一个项目(在0-65535之间) 一般我们把自己的项目发布到80/443这两个端口下 引擎:每一个浏览器都有自己的引擎,谷歌浏览器是v8引擎(webkit),火狐浏览器是Gecko引擎,Ie是Trident引擎 谷歌浏览器控制台NetWork这一项,可以看到当前的客户端向服务器端发送的所有的请求以及请求的状态信息等;对于优化非常的重要 通过NetWork中观看,我们发现当我第一次把html源代码请求回来的时候,浏览器开始按照自己的引擎渲染,在渲染过程中我们还会出现重新向服务器请求css/js/img…,每一次请求步骤和请求html时的步骤是一样的,如果请求的资源次数过多,页面打开的速度和渲染的速度就会变慢,所以我们以后再页面优化的方法中,首先要做的就是减少资源请求 (减少http请求), css合并成一个 或者如果css不是很多的话我们采用内嵌式css js合并成一个 或者采用内嵌式 图片合并(雪碧图技术/css sprite)或者图片延迟加载 ajax请求和资源文件的请求原理是一样的 URI/URL/URNURI=URL+URN统一资源标识符(统一资源信息) url 统一资源定位符http://v.qq.com:80/index.html?name=zhufeng&amp;age=7#bbs http:传输协议 –&gt;客户端给服务器端的内容和服务器端传递给客户端的内容都是通过http传输协议进行传输的(我们可以把http理解为快递小哥 ) v.qq.com:域名 :80 端口号 index.html:请求资源文件名–&gt;告诉服务器我需要请求的资源文件是谁 ?name=zhufeng&amp;age=7:URl问号传参–&gt;客户端传递给服务器端的内容(客户端可以把一些值传递给服务器端,服务器依然可以把一些内容传递给客户端) #bbs URL的hash(哈希值,锚点定位) 传输协议 http:超文本传输协议,除了传输文本外还可以传输其他的东西,例如:xml等 https:更加安全的http ftp:文件传输协议(应用于把项目源文件传递到服务器上) 在不指定服务器端口的情况下,每一种协议会有一个默认找的端口地址 -&gt;http默认会找服务器的80端口 –&gt;https默认会找服务器的443端口 –&gt;ftp默认会找服务器的21端口 URN统一资源名称 初识nodenode是什么我们之前说js是一门运行在客户端(运行在浏览器)的”轻量级”的脚本变成语言,这种说法是错的,–&gt;&gt;js目前不仅仅只能在浏览器中运行,还可以在node中运行 node是衣蛾环境,供js代码执行的环境,我们可以把它等价于浏览器,只不过我们一般会把node这个环境安装到服务器端,这样的话我们就可以在服务器端使用js编写程序了,也就是说js不仅仅是客户端的语言也是服务器端的语言… node和浏览器 node采用的是谷歌的v8引擎来渲染js的(运行的速度快,稳定,我们编写的js代码不需要考虑兼容,比如JSON.parse()这个方法对ie浏览器有兼容,而node的引擎就一个–&gt;谷歌的v8引擎,所以不需要考虑兼容) 浏览器中的’’全局js对象是window,而node环境下的全局js对象是global 浏览器是安装在客户端的,为了保护客户端的安全,基本上不可能提供用js对客户电脑磁盘上的文件进行操作的功能; 但是node环境中提供了对象的I/O操作(服务器上文件的操作),我们使用js可以对服务器磁盘下的文件进行增删改查 node提供给js很多新的方法:http.createServer,fs.writeFileSync,fs.readFileSync… node是基于事件驱动的异步编程(我们在node环境下编写的js程序一般都是异步编程程序) 如何让js代码在node中执行 利用webstorm嵌入的node机制,直接把编写的js通过右键”run xxx.js”在node环境中执行(不建议使用,因为有些时候我们最新执行的操作会受到之前执行的缓存的影响 ) 在命令窗口中执行 node xxx.js js代码发生改变时要重新执行 在命令窗口中直接输入node–&gt;enter即可在当前的命令窗口中编写js代码进行测试了;(rpel命令操作),让当前任务结束就执行两次ctrl+c node模块,模块中是在node环境中供js调取使用的方法 1)内置模块(node环境天生就提供的):http(createServer创建服务),fs(writeFileSync,readFileSync…),url… 2)自定义模块(我们自己定义的模块): 在,node环境中,我们在当前的项目下创建一个js就是创建一个模块,例如,新建一个a.js,就是创建了一个a模块 在b模块中获取a模块中的方法 1) 将我们要在b模块中使用的a模块中的方法在a模块中暴露出来module.exports={fn:fn}/module.exports.fn=fn,前者是批量导出 2) var a=require(“./a”);表示导入当前文件夹下的a模块(不要写成”./a.js”现在a表示的是a这个模块) 3)第三方模块(别人写好的模块我们拿来使用):在node中我们如果需要使用别人的模块,需要使用npm这个命令来进行管理(https://www.npmjs.com) 安装:npm install less -g 将less安装到全局 卸载:npm uninstall less -g 卸载全局中的less模块 安装成功后在js中通过var less=require(“less”);把刚才安装的第三方模块导入到js中,这样的话我们就可以使用这个模块中提供的方法了less.render… node模块中的常用方法http模块http.createServer 创建一个服务var server=http.createServer(function(request,response){//当客户端向服务器端的当前服务(端口号是80这个服务)发送一个请求,并且当前服务已经成功接收到这个请求后,执行这个回调函数}); request(请求):这个参数存放的是所有客户端的请求信息,包含客户端通过问号传参的方式传递给服务器的数据内容 request.url:存放的是客户端请求的文件资源的目录和名称以及传递给服务器的数据地址(即去掉传输协议,域名/ip地址和端口号的部分) response(响应):提供了向客户端返回内容和数据的方法 response.write()向客户端返回内容 response.end()告诉服务器响应结束了(必须加,要不然不知道这次请求的响应什么时候结束) 为server这个服务去监听一个80端口server.listen(80,function(){//当服务创建成功并且端口号监听成功后执行这个回调函数}); 服务创建成功后,如何向服务器端发送请求 在浏览器中输入http://localhost:端口号/(监听的是63342端口,是webstorm给我们生成的服务给创建的一个端口) 在浏览器 中输入本机的ip地址http://本机的ip地址:端口号/ url模块url.parse()用来解析URL地址的 url.parse(str,true);增加true后,在query中存储的是经过处理解析后的结果:把传递进来的多组数据以键值对的方式进行存储 fs模块fs.readFileSync()fs.readFileSync([path+name],[encode])同步读取指定文件中的内容,(同步读取,文件中的内容读取不完就不执行下面的操作,只有读取出来才会执行后续的操作)]]></content>
      <tags>
        <tag>node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react基础]]></title>
    <url>%2F2015%2F12%2F06%2Freact%2F</url>
    <content type="text"><![CDATA[把react的基础知识先进行一个梳理，还有后续。。。 安装 1.安装create-react-app npm install create-react-app -g 2.生成项目 create-react-app xxx 3.启动项目 cd xxxnpm start react的核心概念 元素(elements) 组件(components) 从jsx到页面 表达式插入{} 内可以放任何 JavaScript 的代码，包括变量、表达式计算、函数执行等等。 render 会把这些代码返回的内容如实地渲染到页面上，非常的灵活。 表达式插入不仅仅可以用在标签内部，也可以用在标签的属性上 注意，直接使用 class 在 React.js 的元素上添加类名如 &lt;div class=“xxx”&gt; 这种方式是不合法的。因为 class 是 JavaScript 的关键字，所以 React.js 中定义了一种新的方式：className 来帮助我们给元素添加类名。 还有一个特例就是 for 属性，例如 &lt;label for=&#39;male&#39;&gt;Male&lt;/label&gt;，因为 for 也是 JavaScript 的关键字，所以在 JSX 用 htmlFor 替代，即 &lt;label htmlFor=&#39;male&#39;&gt;Male&lt;/label&gt;。而其他的 HTML 属性例如 style 、data-* 等就可以像普通的 HTML 属性那样直接添加上去。 组件 自定义的组件都必须要用大写字母开头，普通的 HTML 标签都用小写字母开头。 组件可以和组件组合在一起，组件内部可以使用别的组件。就像普通的 HTML 标签一样使用就可以。这样的组合嵌套，最后构成一个所谓的组件树 事件监听在 React.js 不需要手动调用浏览器原生的 addEventListener 进行事件监听。React.js 帮我们封装好了一系列的 on* 的属性，当你需要为某个元素监听某个事件的时候，只需要简单地给它加上 on* 就可以了。而且你不需要考虑不同浏览器兼容性的问题，React.js 都帮我们封装好这些细节了。 没有经过特殊处理的话，这些 on\ 的事件监听只能用在普通的 HTML 的标签上，而不能用在组件标签上*。也就是说，&lt;Header onClick={…} /&gt; 这样的写法不会有什么效果的。 事件中的thisReact.js 调用你所传给它的方法的时候，并不是通过对象方法的方式调用（this.handleClickOnTitle），而是直接通过函数调用 （handleClickOnTitle），所以事件监听函数内并不能通过 this 获取到实例。 event对象和普通浏览器一样，事件监听函数会被自动传入一个 event 对象，这个对象和普通的浏览器 event 对象所包含的方法和属性都基本一致。不同的是 React.js 中的 event 对象并不是浏览器提供的，而是它自己内部所构建的。 React.js 将浏览器原生的 event 对象封装了一下，对外提供统一的 API 和属性，这样你不用考虑不同浏览器的兼容性问题 statesetState 接受对象参数 setState 方法由父类 Component 所提供。当我们调用这个函数的时候，React.js 会更新组件的状态 state ，并且重新调用 render 方法(ReactDOM.render)，然后再把 render 方法所渲染的最新的内容显示到页面上。 传入一个对象的时候，这个对象表示该组件的新状态。但你只需要传入需要更新的部分就可以了，而不需要传入整个对象。 注意，当我们要改变组件的状态的时候，不能直接用 this.state = xxx 这种方式来修改，如果这样做 React.js 就没办法知道你修改了组件的状态，它也就没有办法更新页面。所以，一定要使用 React.js 提供的 setState 方法，它接受一个对象或者函数作为参数。 接收函数参数 这里还有要注意的是，当你调用 setState 的时候，React.js 并不会马上修改 state。而是把这个对象放到一个更新队列里面，稍后才会从队列当中把新的状态提取出来合并到 state 当中，然后再触发组件更新。 当传入的参数是一个函数时: React.js 会把上一个 setState 的结果传入这个函数，你就可以使用该结果进行运算、操作，然后返回一个对象作为更新 state 的对象,这样就可以达到上述的利用上一次 setState 结果进行运算的效果。 state合并 在 React.js 内部会把 JavaScript 事件循环中的消息队列的同一个消息中的 setState 都进行合并以后再重新渲染组件,所以,在使用 React.js 的时候，并不需要担心多次进行 setState 会带来性能问题。 propsprops不可变 props 一旦传入进来就不能改变 你不能改变一个组件被渲染的时候传进来的 props。React.js 希望一个组件在输入确定的 props 的时候，能够输出确定的 UI 显示形态。如果 props 渲染过程中可以被修改，那么就会导致这个组件显示形态和行为变得不可预测，这样会可能会给组件使用者带来困惑。 但这并不意味着由 props 决定的显示形态不能被修改。组件的使用者可以主动地通过重新渲染的方式把新的 props 传入组件当中，这样这个组件中由 props 决定的显示形态也会得到相应的改变。 总结: 1.为了使得组件的可定制性更强，在使用组件的时候，可以在标签上加属性来传入配置参数 2.组件可以在内部通过 this.props 获取到配置参数，组件可以根据 props 的不同来确定自己的显示形态，达到可配置的效果。 3.可以通过给组件添加类属性 defaultProps 来配置默认参数。 4.props 一旦传入，你就不可以在组件内部对它进行修改。但是你可以通过父组件主动重新渲染的方式来传入新的 props，从而达到更新的效果。 警告:你们安装一个新模块之后，将不再能执行脚本。需要重新安装脚本 需要安装一下这个 : npm install react-scripts -S 参考文档http://www.css88.com/react/http://www.redux.org.cn/https://reacttraining.cn/https://scriptoj.com]]></content>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML5常用标签]]></title>
    <url>%2F2015%2F08%2F10%2FHTML5%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE%2F</url>
    <content type="text"><![CDATA[HTML5 是下一代 HTML 标准。HTML , HTML 4.01的上一个版本诞生于 1999 年。自从那以后，Web 世界已经经历了巨变。HTML5 仍处于完善之中。然而，大部分现代浏览器已经具备了某些 HTML5 支持。 HTML5和CSS3 是两种不同的文本语言 新特性 用于绘画的 canvas 元素 用于媒介回放的 video 和 audio 元素 html4 用来播放视频使用swf （flash） 对本地离线存储的更好的支持 新的特殊内容元素，比如 article、footer、header、nav、section 新的表单控件，比如 calendar、date、time、email、url、search 更好的服务开发，更加的利于SEO优化 新增的语意标签article 文章 文章页aside 侧边栏datalist 规定input的各种情况1234567&lt;datalist id="browsers"&gt; &lt;option value="Internet Explorer"&gt; &lt;option value="Firefox"&gt; &lt;option value="Chrome"&gt; &lt;option value="Opera"&gt; &lt;option value="Safari"&gt;&lt;/datalist&gt; footer 规定body內或文章內的页脚内容header 规定body內或文章內的页头部分一个页面中可以有多少个header和footer标签？从语义上讲最好就出现一对可以出现多个head可以出现几个？只有一个mark 定义文本 带有标记nav 定义导航（该放什么标签就放什么标签 div.nav）section 章节 == div 章节details 标签规定了用户可见的或者隐藏的需求的补充细节。details 标签用来供用户开启关闭的交互式控件。任何形式的内容都能被放在 details 标签里边。details&gt;元素的内容对用户是不可见的，除非设置了 open 属性。summary 标签为 details元素定义一个可见的标题。 当用户点击标题时会显示出详细信息we1234567&lt;details&gt;&lt;summary&gt;Copyright 1999-2011.&lt;/summary&gt;&lt;p&gt; - by Refsnes Data. All Rights Reserved.&lt;/p&gt;&lt;p&gt;All content and graphics on this web site are the property of the company Refsnes Data.&lt;/p&gt;&lt;/details&gt;&lt;p&gt;&lt;b&gt;注意：&lt;/b&gt;目前只有 Chrome 和 Safari 6 支持 summary 标签。&lt;/p&gt; 此外 我们再追加两个标签pre 定义预格式文本 – 所见即所得code 定义计算机代码文本 一个网站有哪些主题的页面 首页 列表页 专题页 列表页 文章页 文章页 功能页（搜索、用户信息获取页面、结算页面）【表单】]]></content>
      <tags>
        <tag>html5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ajax和jsonp]]></title>
    <url>%2F2015%2F05%2F20%2Fajax%E5%88%86%E9%A1%B5%2C%E8%B7%A8%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[跨域 同源 当前页面的url: http://localhost:1234/index.html 获取数据的url: http://localhost:1234/getUserList —&gt;&gt;这种情况就可以使用ajax来获取数据 非同源(跨域) 当前页面的url: http://localhost:1234/index.html 获取数据的url: http://matchweb.sports.qq.com/kbs/hotMatchchList —&gt;&gt;这种情况就不可以使用ajax来获取数据 判断同源与非同源的三个维度(页面的地址和获取数据的url地址进行比较) 协议 域名 端口号 这三者都相同就是同源,有一个不一样就是跨域,跨域不可以使用ajax只有同源才可以用ajax 用到跨域请求的情况我们在自己的网站上需要展示别人网站上的数据–&gt;&gt;需要在自己服务器上访问获取其他网站服务器的数据,例如 1)需要展示百度,腾讯,微博等第三方平台的数据 2)如果项目比较大,访问的人也比较多,一般都会用多台服务器管理,服务器之间的访问就是跨域–&gt;&gt;也就是说只要不是同一个服务器的请求都叫做跨域 3)二级域名sports.qq.com向一级域名www.qq.com获取数据也是跨域 跨域请求的方式 jsonp iframe postMessage document.domain crossDomain 一般最常用的是jsonp jsonpjsonp和ajax的相同点都是客户端向服务器端发送请求:给服务器端传递数据或者从服务器端获取数据的方式; 与ajax的区别ajax属于同源策略 jsonp属于非同源策略(跨域请求)–&gt;&gt;实现跨域请求的方式有很多,只不过jsonp是最常用的 script标签是没有同源和非同源之分的,src中引入的js文件是自己的服务器上的或者别人服务器上的都可以(换句话说我们的script标签可以向其他的服务器发送请求,并且其他服务器也可以接收到请求,把你需要的内容返回给客户端),其他的标签link img audio iframe也都是可以的 jsonp的原理利用script标签不存在跨域限制,我们把需要的请求数据的地址赋给src属性,这样就可以从别人服务器上获取数据,这样还不够,还需要在js中将浏览器获取到的数据得到,进行后续的操作 12345678910111213&lt;script&gt; var ss=null; function ff(result) &#123; ss=result; console.log(ss); &#125;&lt;/script&gt;&lt;script type="text/javascript" src="http://matchweb.sports.qq.com/kbs/hotMatchList?callback=ff"&gt;&lt;/script&gt;&lt;!--这里获取到数据后会直接给ff传值并让ff自动执行--&gt;&lt;script&gt; console.log(ss);//获取的数据已经被存储在ss这个变量中了;&lt;/script&gt;//腾讯服务器接受到请求,去查找参数callback的值,比如:我们这里传的ff,然后进行解析,赋值'ff(&#123;"name":"aa","age":"12"&#125;)'然后把字符串返回给客户端,客户端让ff执行就可以了 jsonp请求是get的请求方式 jQ中的jsonp请求：JQ会默认给url后面追加一个变量来清缓存,并且JQ处理jsonp请求的时候,会默认帮我们在请求地址后面创建一个函数 例如:callback=jQuery3210044305935482184644_1498364421862]]></content>
      <tags>
        <tag>跨域</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[html+css笔记之六]]></title>
    <url>%2F2015%2F04%2F28%2Fhtml%2Bcss%E7%AC%AC%E5%85%AD%E5%A4%A9%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[回顾css的引入方式 行内式 将css属性通过style这个标签属性直接写在标签中 内嵌式 将css属性写在style元素内，一般放在head元素内 外联式 将css、属性写在css文件中，通过link元素将css、文件引入到html中，一般这个元素写在head元素内 导入式 将css属性写再css文件中，通过@import url（“”）/import“url”语句将css文件导入到html文件内 @import 必须写在style元素内或者css文件内 @import必须写到所在文件的第一行 css选择器语法：选择器{声明；声明；}每一个声明后面必须跟着分号 标签选择器 权重1 直接将标签名当选择器 类选择器 权重10 将标签属性class的属性值当做选择器，选择器前面要加一个“.” id选择器 权重100 将标签属性id的属性值当选择器，选择器前面要加一个井号 通配符选择器*{} 选择当前文档下的所有元素 权重0&lt;x&lt;1 分组选择器 权重分开计算 将不同的选择器有逗号隔开，将同样的css属性一起给到不同的html元素 交集选择器 所有选择器之和 两个选择器紧挨在一起 标签选择器和其他选择器组合的时候，标签选择器要放在前面 ​ div.className{} .className1.className2{} 组成这个选择器的两个属性或标签必须是同一个html元素的属性 后代选择器 权重 所有选择器之和 父代空格子代{} 父代和后代不一定是相邻的，只要符合后代关系就可以。 子代选择器 权重 所有选择器之和 父级选择器&gt; 子代选择器{} 两个选择器在从属关系上是相邻的，而不是位置上的 相邻兄弟选择器 权重 所有选择器之和 哥哥选择器+相邻弟弟选择器{} 只能选择第一个弟弟元素 属性选择器 权重10 将元素的标签属性名和属性值当做选择器，必须写在[中] [属性名]{} [属性名=属性值]{} 伪类选择器 权重 10 指元素的一个状态，点击 ，经过。。。 基本选择器：伪类{} 例： .box:hover{} 伪元素 before after 基本选择器：div:before{display：；content：“”；} content的引号不能少，里面可以没有内容 displayblock 块级元素遵循的浏览器渲染模式BFC 独占一行 子集元素默认会在父级元素的左上角，平级元素会向下排布 在不设置宽度的时候，宽度是父级元素内容的宽度，高度是本身内容的高度 可以直接设置盒子模型的所有属性 可以嵌套所有的属性 p dt h1-h6不能嵌套其他的块级元素inline 行内元素遵循的浏览器渲染模式IFC 都会在一行显示,从左到右,到达父级盒子最大宽度后自动折行 宽度不能设置,宽度和高度是由本身的内容撑起来的 可以设置border,padding的左右值和margin的左右值 行内元素不能嵌套块级元素 a元素必要的时候可以嵌套其他块级元素(整个模块添加超链接的时候,才可以用) 会受到内容长度的影响,出现基线对齐(上下对齐/垂直对齐)将对齐方式改变为盒子顶部对齐 在编辑代码的时候，元素之间有空格或回车的时候，在页面显示时，两个盒子之间有间隙inline-block 行内块级元素 都会在一行显示,从左到右,到达父级盒子最大宽度后自动折行 不设置宽高的时候,宽高有内容 决定 直接设置宽度和高度,margin和padding 编辑代码的时候,元素之间有空格或回车的时候,在页面显示时,两个盒子之间有间隙(用font-size:0清除) 总结:常用的块级元素:div ul ol li p h1-h6 dl dt dd table tr thead tbody tfoot form常用的行内元素:span a em i b strong sup sub u img(img可以直接设置宽高,但是不独占一行) 浮动 left 左浮动 从第一个元素开始，在父级元素内，从左向右排列，到达父级元素的最大宽度时,会自动折行 right 有浮动从第一个元素开始，在父级元素内，从右向左排列，到达父级元素的最大宽度时,会自动折行 none 去除浮动 将浮动元素的浮动属性除去 文档流：行内元素和块级元素默认的渲染模式 特点: 脱离文档流(父级元素找不到子级元素),相当于来到了第二层级,平行于基本的文档流 所有元素都可以设置这个属性a img div li ul。。。 浮动元素可以直接设置盒子模型的所有属性 浮动元素不设置宽高,宽高是本身内容的大小 行内元素、行内块级元素和文字会围绕着浮动元素排列 有浮动属性的元素,排列方式听浮动的,没有浮动属性的元素,听display的 1234div&#123; display:inline-block; float:right; 浮动生效&#125; 浮动带来的影响:父级元素找不到浮动的子级元素,所以一般浮动元素的父级元素如果不设置高度的时候,它的高度就是0, 清除浮动的方法给父级元素高度不管内容是什么,高度都是固定的 给父级元素设置overflow:hidden属性是将元素拉回文本流 给父级元素设置float属性(父子元素都是浮动就可以相互识别了)clear:both只是用来清除浮动 带有这个属性的元素必须是块级元素 带有这个属性的元素必须放在最后一个浮动元素之后 带有这个属性的元素不能带有float属性利用伪类清除浮动是工作中最长用的方法12345678910&lt;style&gt;.clear&#123;*zoom:1;&#125;/*兼容低版本浏览器*/.clear:after&#123;display:block;content:"";clear:both;&#125;/*兼容高版本浏览器*/&lt;/style&gt;&lt;ul class="clear"&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;!--::after--&gt;&lt;/ul&gt; 用法: 1,这个属性被放在最后一个浮动元素的最后面 2,这个属性依附的元素必须是一个块级元素display:block 3,这个块级元素不能有float的属性利用伪类清除浮动是工作中最常用的方法 定位相对定位特点: 不脱离文档流 参照物是本身 给绝对定位的元素做参照物 发生位置改变的时候原来的位置还占用 层级大于文档流内其他元素(会盖在其他元素之上) 当top和bottom同时设定是,top生效,left和right是left生效 position:relative和float同时设定时,都生效,先浮动后定位(先脱离文档流) 盒子自己发生位置改变,又不影响其他元素的时候选用相对定位 绝对定位 脱离文档流 所有元素默认都会去找参照物的起点位置,互相叠盖在一起 宽度不设置时,宽度和高度由自身内容决定 绝对定位的元素如果不设置四个方向的值并且同级之前有其他内容,他会排在这个内容之后 当绝对定位元素有宽和高的时候,top和bottom同时设置,top生效,left 和right,left生效。 绝对定位元素设置宽高100%时,继承的宽高是其参照物的宽高 在不设置参照物时,参照物是body 可以人为设置参照物 需是这个绝对定位元素的父级(可不是紧邻的父级)元素 参照物元素必须是带有定位属性的元素(可以是相对,绝对,固定) 父级元素都有定位属性,那么绝对定位元素的参照物是离他最近的那个父级元素 平级元素不能作为参照物 固定定位 脱离文档流 参照物始终是可视窗口 不设置宽高时,宽高时内容大小 多用在辅导航,返回头部等位置 &lt;a href=&quot;#top&quot;&gt;top&lt;/a&gt;a标签中只写一个# 或者 什么都不写 或者 写#top都可以实现回到顶部的特点 去掉定位属性position: staticz-index改变定位元素的层级关系 不能改变父子之间的层级关系(正值) 可以设置负值,跑到所有元素之后 当父子元素都有z-index值得时候,如果父级元素之间有值,那么子级元素不会出来进行比较]]></content>
      <tags>
        <tag>html，css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[html+css笔记之五]]></title>
    <url>%2F2015%2F04%2F10%2Fhtml%2Bcss%E7%AC%AC%E4%BA%94%E5%A4%A9%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[块级元素的特点 独占一行，在所在父级元素内依次向下排列，从左上角开始 宽度和高度在不设置的情况下，宽度继承父级元素内容的宽，高度由本身内容决定 可以直接设置盒子模型的所有属性(width，height，padding，border，margin ) 可以嵌套其他元素行内元素和行内块级元素 在一行显示，从左到右，达到父级元素最大宽度时，会自动折行 在编辑代码时，元素之间有回车或者空格，在页面显示时，盒子和盒子之间会有间隙 默认是基线对齐 默认不设置宽度的时候，继承父级元素的100%宽度 行内元素 宽度和高度不能设置 可以设置padding和margin的左右值行内块级元素 可以设置盒子模型的所有属性在布局中如何使用css属性将块级元素放到一行排布 float:left/right 盒子可以从左向右 或者 从右向左 display：inline/inline-block/table inline 盒子不能设置宽度和高度 inline-block 可以设置宽高但是只能从左到右 table 可以设置宽高但是只能从左到右 给父级元素设置display：table 给子集元素设置display：table-cell（单元格）background背景背景和内容的关系，背景永远在内容之后space ：平铺并且适应尺寸大小，图片小于盒子的时候才能使用no-repeat 不平铺repeat-xrepeat-ybackground-size：可以是像素可以是百分比（针对于盒子大小）background-position：center center；让图像的中心点和盒子的中心点对齐background-size：cover（100% auto）background-image: url(“”); –&gt; 引入背景图片background-position: 3px 5px;background-origin: content-box; –&gt; 规定背景图片定位的 如何让图片的中心点和盒子的中心重合background-position: center center; 1234height: 300px;background-color: yellow;background-image: url(&quot;导航头部/images/icon.png&quot;),url(&quot;导航头部/images/logo.png&quot;);background-position: top center,right bottom;/*ie 678 （低版本浏览器） 不兼容*/ 12background: yellow url(&quot;导航头部/images/icon.png&quot;) no-repeat 10px 20px;background-size:100% auto; 绝对定位 想让盒子在父级盒子的哪个位置，就在哪个位置 脱离文档流（父级盒子找不到这个定位子级盒子的宽度和高度了） 必须有一个参照物，这个参照物只能是这个定位盒子的父级元素（只要是包含的就可以），父级元素还必须有定位属性 定位的元素层级高于普通元素 当行内元素或行内块级元素设置line-height不生效的时候，可以将这个元素display属性值设置为block块级元素通过display:inline-block;转化后，ie7不会识别，所以要在display:inline-block;之后添加一个*display:inline;12display: inline-block;*display:inline; 第二种解决方式是将这个元素直接设置为float浮动的元素 在ie7中，如果结构123456&lt;style&gt;b&#123;float:right;&#125;&lt;/style&gt;&lt;h3&gt;文字 &lt;b&gt;&lt;/b&gt;&lt;/h3&gt;b元素会跑到h3元素的下方将“文字”用一个元素包起来，将这个元素float:left;即可]]></content>
      <tags>
        <tag>html，css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[同步编程和异步编程]]></title>
    <url>%2F2015%2F04%2F10%2FAJAX%E4%B8%AD%E7%9A%84%E5%90%8C%E6%AD%A5%E7%BC%96%E7%A8%8B%E5%92%8C%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[JS中的同步编程和异步编程JS是属于单线程的,我们最好使用异步编程 js中属于异步编程的有: 定时器都是异步编程的(定时器的时机就算是设置为零也不是立马执行,而是需要等待一段时间:谷歌5-6ms;ie 10-13) 时间绑定都是异步编程的 回调函数也可以理解为异步编程 在AJAX中可以使用异步编程 JS中的同步编程和异步编程ajax中的同步当ajax任务开始后(xhr.send),一直需要到readyState===4 的时候任务才结束,此时才可以处理其他的事情; ajax中的异步当ajax任务开始后(xhr.send),不需要等到readyState===4 ,依然可以处理其他的任务并且只有当其他的任务完成后,才会去看readyState是否为4了,到达4的时候再去 做一些相关的操作;]]></content>
      <tags>
        <tag>同步/异步</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[html+css笔记之四]]></title>
    <url>%2F2015%2F03%2F27%2Fhtml%2Bcss%E7%AC%AC%E5%9B%9B%E5%A4%A9%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[选择器回顾1234.div ul li&#123;&#125;第一步选择这个文档中所有的li第二部选择哪些li是ul下面的第三步选择哪些li是ul下面，ul还是div下面的 选择器的组成不要超过三个选择器的查找机制是从右向左 交集选择器 一个元素具有两个属性，可以将这两个属性做成交集选择器组成交集选择器的两部分，必须属于同一个元素 1234h1.p1&#123;&#125; -- &gt; 什么都选择不到p.p1&#123;&#125; p.p2&#123;&#125; .p1.p2&#123;&#125; p.p3&#123;&#125;&lt;p class="p1 p2 p3"&gt;&lt;/p&gt;&lt;h1&gt;&lt;/h1&gt; 后代选择器（派生选择器） 祖籍 子级{}只要存在后代关系即可 子级选择器 父级&gt;子级{} 父子两个元素是相邻的 display根据这个属性可以将元素分成不同的类型,也会是显示出不同的状态,例如属性值为block的时候,这个元素会独占一行,如果属性值为inline的时候,所有这个属性值得元素都会在一行显示,属性值为none,元素会在页面上消失所有元素都有天生自带的display属性和属性值,叫做内置属性。 block块级元素特点: 独占一行 可以设置盒子模型的所有属性(width,height,border,padding,margin) 默认宽度是父级元素内容的宽度,高度是本身内容的高度 可以嵌套其他元素 dt不能嵌套其他块级,可以嵌套行内元素等 p不能嵌套块级元素,可以嵌套其他行内元素等 永远会在父级盒子左上角开始排布，从上到下 人为设置的样式要比元素自带的权重高块级元素这些特点，我们将其称作 BFC（block formatting context）块状元素在上下文中的渲染模式（块状元素应该怎么排布） inline行内元素特点： 在一行显示 不能设置宽度，高度-padding，margin 的上下值设置不生效，左右值生效 默认宽度高度是本身内容的宽高 几个行内元素默认的垂直方向对齐方式是基线对齐 在编辑代码时，如果行内元素之间有回车或空格，那么在页面显示的时候，就会有间隙 将font-size设置为0，可以解决这个问题，但是要重新设置其他文本 行内元素不能嵌套块级元素 vertical-align 改变行内元素和行内块级元素的基线对齐方式 值 作用 top 所有平级元素，去找最高（高度最高）元素的顶部进行对齐 bottom 所有平级元素，去找最高（高度最高）元素的底部进行对齐 middle 所有平级元素，去找最高（高度最高）元素的中部进行对齐 length（数值） px % 改变对齐方式的时候，所有元素都要添加这个属性 none 将这个元素在页面上隐藏起来（完全消失） 怎样再显示出来：将none用其他的属性值替换，一般使用block 盒子模型每一个元素在html中都是一个盒子，用来装其他的盒子或者是内容 可以将html页面看作是一个仓库，仓库中从上到下摆了很多的箱子，易碎品（盒子和盒子之间要有距离 内容与盒子之间 盒子本身要有厚度）height：100%指的是继承父级元素”内容”的高度 父子关系的时候，在设置margin值得时候，一般只设置上和左右，不会设置下和右 margin 支持负值margin-left：-30 margin-left和margin-top为负值的时候跑出浏览器的部分会被吃掉，不会撑开整个页面。 margin-top的传递问题如果父级元素没有padding-top或border-top的值时候，子元素设置margin-top值，会将这个值传递给父元素 解决方法 给父元素一个属性，overflow为hidden（不建议使用） 将子集元素的margin-top值去掉，改成父级元素的padding-top值 margin-left/margin-right在ie6中会双倍当元素浮动的时候，有左右的外边距，有时候ie6会出现双倍边距的问题。解决方案： 给这个元素添加overflow：hidden 写ie6的兼容方式，例如：1234567div&#123; float:left margin-left:10px _margin-left:5px/*浏览器是ie6的时候，读取这句话*/ css属性为hack &#125; ！important出现在css里面的时候，这个属性会覆盖掉所有之前设置的样式css hack overflow: 盒子内容多余部分的处理方法值：hidden 直接隐藏多余的scroll 如果有多余部分出现滚动条，如果没有就不出现auto 不论是否有多余部分，都会出现滚动条]]></content>
      <tags>
        <tag>html，css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[html+css笔记之三]]></title>
    <url>%2F2015%2F03%2F20%2Fhtml%2Bcss%E7%AC%AC%E4%B8%89%E5%A4%A9%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[CSS层叠样式表回顾作用：为html结构层增加样式层，常用的css引入模式为外联式，因为外联式可以加快浏览器加载网页的速度，可以重复使用，可以多个html使用一套html样式表，利于修改。（iframe可以用来引入html文件但是会固定尺寸，是内容无法自适应网页尺寸的变化。） 四种引入方法 行内式： 格式&lt;标签 style=“属性：值”&gt; 内嵌式 ： 一般放在（并不是必须）head里面，便于首先加载样式 外联式：&lt;link rel=“stylesheet” href=“url” type=“text/css”&gt;css文件只存在选择器和选择器包裹的样式，不存在标签对 导入式：@import“url”（只是声明，会等内容加载完之后再加载样式，不能被js调用）放在style里面的第一行或者在css文件的第一行。当有多个css文件的时候，可以使用导入式先导入到一个css文件中再导入到html中。 外联式和内嵌式一般都放在head里面，便于首先加载。 CSS选择器因为html和css分离了，那么就出现了如何选择一个元素将样式添加给它的问题，就此出现了选择器。 选择器的语法选择器后面跟着大括号{}，包裹一个或者多个声明。通过不同的选择器可以选择不同的html元素标签选择器 标签名{key：value；key：value；} 可以批量选择“选择器名称相同的元素”，相当于人的姓 权重为1类选择器 .name{key：value；key：value；} 一个html元素可以有多个类名如&lt;p class=name1 name2&gt; 类名可以重复使用，相当于人的名 权重为10123&lt;style&gt;.title&#123;color:red;&#125;&lt;/style&gt;&lt;h1 class="title title1"&gt;类选择器&lt;/h1&gt;&lt;h2 class="title"&gt;&lt;/h2&gt; ID选择器 #name{key：value；key：value；} 一个html元素，id属性值只能用一次，也就是说id具有唯一性（只能用一次） 123&lt;style&gt;#title&#123;color:red;&#125;&lt;/style&gt;&lt;h1 id="title"&gt;id选择器&lt;/h1&gt;&lt;h2 id="title"&gt;错误的 不识别&lt;/h2&gt; 权重为100 后代选择器（派生选择器） 可以在一个根元素范围内，查找它包含的后代元素 语法：祖辈选择器空格要查找的后代选择器{} 权重：选择器之和123456789101112131415161718192021222324252627&lt;style&gt;.div1 ul span&#123;&#125;&lt;/style&gt;&lt;div class="div1"&gt; &lt;ul&gt; &lt;li&gt; &lt;span&gt;只选择了这个span元素&lt;/span&gt; &lt;/li&gt; &lt;/ul&gt; &lt;ol&gt; &lt;li&gt; &lt;span&gt;wenzdskaldjaslk&lt;/span&gt; &lt;/li&gt; &lt;/ol&gt;&lt;/div&gt;&lt;div class="div2"&gt; &lt;ul&gt; &lt;li&gt; &lt;span&gt;wenzdskaldjaslk&lt;/span&gt; &lt;/li&gt; &lt;/ul&gt; &lt;ol&gt; &lt;li&gt; &lt;span&gt;wenzdskaldjaslk&lt;/span&gt; &lt;/li&gt; &lt;/ol&gt;&lt;/div&gt; 后代选择器在写的时候，尽量控制在三个左右 通配符选择器 * *{key：value；key：value；} 匹配全部html元素 权重：0&lt;*&lt;1 一般不使用，因为全部匹配耗性能###（标签）属性选择器属性必须被中括号包裹 [属性]{key：value；key：value；} 例子：[title（a的一个属性）]{key：value；key：value；} 权重：10 a[title]{key：value；key：value；} 利用标签的属性名和属性值来选择html元素 权重：11（标签+属性=1+10） [属性=值]{key：value；key：value；} 可以通过属性值的不同进行选择 权重：10,等同于[属性]{key：value；key：value；} 属性选择器我们不会使用class，因为class可以直接使用类选择器 12[class=div1]&#123;&#125;/*如果 class值有两个 不能这样使用*/&lt;div class="div1 p1" id="div2" type="" title=""&gt;&lt;/div&gt; 分组选择器（并集选择器） 作用（应用场景），同一份css样式，可以一次性的添加给多个不同的html元素 写法选择器1，选择器2，选择器3{key：value；key：value；} 权重：分组选择器将不同的html分为一组，权重计算的时候都是独立计算的，不会叠加。12.box,li,.p1&#123;color: yellow;&#125;.box&#123;color: green;&#125; 交集选择器 两种属性同属一个元素的时候，我们可以使用交集选择器来进行元素的准确选择 权重：所有组合选择器的权重之和 组合选择器之间没有任何的符号和空格，组合时如果有标签选择器，标签选择器要放在前面。 作用：精确查找元素，增加选择器的权重 组合规则：两个选择器可以是：标签和类名，标签和属性，标签和id，两个类选择器子集选择器存在包含关系的元素选择器，通过父级确定选择子级语法：父级选择器&gt;子级选择器{}父级选择器是用来确定取值范围子级选择器才是我们要添加样式的那个元素权重：所有选择器之和 12345678910&lt;style&gt;ul&gt;li&#123;color:red;&#125; /*选择ul下的li*//*权重 2*/&lt;/style&gt;&lt;ul&gt; &lt;li&gt;M&lt;/li&gt;&lt;/ul&gt;&lt;ol&gt; &lt;li&gt;M&lt;/li&gt;&lt;/ol&gt; 子级选择器必须是紧邻的父子关系 相邻兄弟选择器通过哥哥元素选择弟弟元素，两个选择器之间用+相连语法:哥哥选择器+弟弟选择器{}权重：选择器之和12345678910&lt;style&gt; .list1+li&#123;color: red;&#125; .list3+li&#123;color: green;&#125;&lt;/style&gt;&lt;ul&gt; &lt;li class="list1"&gt;11111&lt;/li&gt; &lt;li&gt;22222&lt;/li&gt; &lt;li class="list3"&gt;33333&lt;/li&gt; &lt;li&gt;4444&lt;/li&gt;&lt;/ul&gt; 伪类选择器给一个元素添加某种状态例如：鼠标经过时，获取焦点时，鼠标点击时权重：101234567&lt;style&gt; a:link&#123;color: blue;&#125;/*a:link 是默认状态*/ a:hover&#123;color: red;&#125;/*a:hover 是鼠标经过状态*/ a:active&#123;color: green;&#125;/*a:active 是鼠标点击状态*/ a:visited&#123;color: blueviolet;&#125;/*a:visited 鼠标点击后的状态*/&lt;/style&gt;&lt;a href="javascript:void (0);"&gt;最初形态&lt;/a&gt; 伪元素选择器通过css代码向指定元素内添加假的（html中不存在）元素1234567891011121314&lt;style&gt;div:before&#123; display: block; content: "我是before"; font-size: 40px; color: white;&#125;div:after&#123; display: block; content: "我是after"; font-size: 60px; color: aqua;&#125;&lt;/style&gt; before会出现在div之前after会出现在div之后 使用为元素的时候要保证两个前提 要有display这个属性 要有cotent这个属性，这个属性的属性值可以为空，但是引号不可少，cotent：“” css属性的继承子级元素从父级元素身上继承一些可以继承的css属性123456&lt;style&gt;div&#123;color:red;&#125;&lt;/style&gt;&lt;div&gt; &lt;p&gt;我是一个p标签&lt;/p&gt;&lt;/div&gt; 可以被继承的css样式：和文字与列表有关的样式可以被继承 如果css属性不带有继承性，如何继承父级身上的属性，可以将要继承的属性的属性值写上–inherit 12ul&#123;float:left;&#125;li&#123;float:inherit;&#125; /*float:inherit===float:left;*/]]></content>
      <tags>
        <tag>html，css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[html+css笔记之二]]></title>
    <url>%2F2015%2F03%2F15%2Fhtml%2Bcss%E7%AC%AC%E4%BA%8C%E5%A4%A9%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[总结 前端三层：HTML CSS JS (JAVASCRIPT) 网页（就是一个html文件） 网站（有很多网页组成） 站群（有很多网站组成） 标签（由尖括号和关键字（普通文本）组成的超文本） 关键字（普通文本），在编辑html这门语言的时候，相关组织将这些文本归纳到了一定的规则中，使他有了特殊的含义和作用 标签的分类：开始标签，结束标签，空标签 123&lt;开始标签&gt;&lt;/结束标签&gt;&lt;空标签/&gt; 标签属性：他是用来描述标签功能的，一般写在开始标签中，跟在标签名的后面，用空格隔开，一个标签可以有很多标签属性，每一个属性都用空格隔开 12&lt;开始标签 属性名=“属性值” 属性名=“属性值”&gt;&lt;/结束标签&gt;&lt;img src="url" alt="备注"&gt; 元素：由标签（开始和结束标签中包含内容）和内容组成，元素中内容可以为空，一个空标签也叫做一个元素12&lt;div&gt;content&lt;/div&gt; -- &gt; div元素&lt;img src="url" alt="备注" /&gt; -- &gt; img元素 标签属性经过html的进化，舍弃了有关样式的标签属性，保留功能的标签属性例如舍弃 width bgcolor align ，这些样式描述都放在css 里面保留 alt、title src href… 常用的标签 div标签是无意义标签，用来划分大区域 span 无意义标签 作用：行内小模块区分。 b作用：加粗 strong：加粗强调 i 作用：斜体 em 作用：强调*斜体* p 段落 h1-h6 标题 a 超链接 锚点 &lt;a href=&quot;javascript:void (0);&quot;&gt; dl 定义列表 （常用在新闻标题和摘要） dt 定义标题 dd 定义描述 一个dt可以有多个dd进行描述 table 表格 caption 标题 thead 表头 tr &gt; th(标题单元格) tfoot 表尾 tr &gt; td(普通单元格) tbody 表身 tr &gt; td(普通单元格) thead和tfoot分别有一个 tbody可以有多个tfoot一般放置在thead的后面，为了防止tbody中的内容过多，tfoot加载过慢的情况，但是虽然书写位置在前面，在页面中显示的时候，这部分依然在整个表格的最后面如果table用来搭建结构，我们只需写tr和td 12345678&lt;table&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 表单 获取用户信息 &lt;form&gt;&lt;/form&gt; 12345678910111213141516171819202122&lt;form&gt; &lt;input type="radio" name="ok" checked="checked"&gt;&lt;!--单选按钮--&gt;&lt;label&gt;满意&lt;/label&gt;&lt;!--label 描述表单元素功能--&gt; &lt;!--type 类型--&gt; &lt;!--name 名字--&gt; &lt;!--checked 选中--&gt; &lt;input type="radio" name="ok"&gt;&lt;!--单选按钮--&gt;&lt;label&gt;不满意&lt;/label&gt; &lt;input type="checkbox"&gt;&lt;label&gt;篮球&lt;/label&gt; &lt;input type="checkbox" checked&gt;&lt;label&gt;美女&lt;/label&gt; &lt;input type="checkbox"&gt;&lt;label&gt;彭于晏&lt;/label&gt; &lt;input type="checkbox"&gt;&lt;label&gt;陈冠希&lt;/label&gt; &lt;input type="checkbox"&gt;&lt;label&gt;杨颖&lt;/label&gt; &lt;input type="checkbox"&gt;&lt;label&gt;维密&lt;/label&gt; &lt;textarea maxlength="10" minlength="1"&gt;&lt;/textarea&gt;&lt;!--文本域--&gt; &lt;!--maxlength 字符输入的最大长度--&gt; &lt;br&gt; &lt;label&gt;姓名&lt;/label&gt;&lt;input type="text"&gt; &lt;br&gt; &lt;label&gt;手机&lt;/label&gt;&lt;input type="text"&gt; &lt;br&gt; &lt;label&gt;密码&lt;/label&gt;&lt;input type="password"&gt;&lt;/form&gt; html的基本结构123456789101112&lt;!doctype html&gt;文档声明：必须放在html文件的第一行，如果没有文档声明，会触发浏览器的怪异模式html元素：告知浏览器我是一个html文件 &lt;head&gt; head元素：文档的头部，一般放在文档头部的内容是不会显示在浏览器可视区内的 &lt;meta charset="utf-8"&gt; &lt;title&gt;标题&lt;/title&gt; title中的内容也会被浏览器抓取 &lt;/head&gt; &lt;body&gt; 供用户浏览的所有内容，标签，图片，文本，视频。。。 &lt;/body&gt; 一个html文件也可以叫做一个网页，又可以称作是一个文档（document）整个文档从html元素开始，一直向下分支延伸，像一棵大树一样，所以我们将html元素叫做这个文档的根元素 ##&lt;!DOCTYPE html&gt;文档声明作用：定义这个文档的类型，浏览器先识别这句话。会按照定义的类型去解析这个文档123&lt;!DOCTYPE html&gt;html5的文档声明，浏览器就会按照html5的规则解析这个文档同样html4的文档，浏览器就会按照4的规则解析这个文档 所有高版本都会向下兼容，所以可以把所有的版本都写成html5的声明 文档声明必须写在html文件的第一行 文档声明不区分大小写 如果html文件没有文档声明，会触发浏览器的怪异模式 文档声明不是一个html标签 html元素此元素告诉浏览器其自身是一个html文档是由开始和结束标签组成的。 ###head元素整个文档的头部，head元素自带隐藏功能，display： none里面的内容不会隐藏，只不过一般放置在head元素中的其他元素和内容也是自带隐藏功能的，例如link、meta &lt;meta&gt;规定了html文档的原信息 charset=UTF-8 文档的编码 utf-8国际通用编码 gbk gb2312 name=”keyword” content=”HTML5,JS….”关键词 SEO优化 title元素html文档名称一个页面只有一个title元素文字显示在浏览器的页卡（页头）位置link &lt;link href=&quot;favicon.ico&quot; type=&quot;image/x-icon&quot; rel=&quot;shortcut icon&quot;&gt; 图标让设计师生成 一般这个图片放在整个项目的根目录下 显示在浏览器页卡位置，title内容之前 &lt;link rel=&quot;stylesheet&quot; href=&quot;url&quot; type=&quot;text/css&quot;&gt; 引入一个外部的css文件 rel 不能缺少 stylesheet 样式表 type 可以省略 但是建议写全body元素定义整个文档的主体部分，所有展示给用户的内容，都要放在这个元素中，body中有常用的html元素（div ul），文本内容、音频、视频、图片、表单… … 12345678&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt;&lt;/body&gt;&lt;/html&gt; 标签语义化head标签就知道是文档头部浏览器会按照每个标签的意义去解析标签中的内容h1是个大标题，意义很重要，搜索引擎会重点抓取这个里面的内容 p–&gt; 段落，浏览器在展现这一部分的时候，会独立成一块，让文档结构更加清晰，给用户更好的交互体验。 作用： 重要的内容要放在语义重要的标签中，利于SEO优化（搜索引擎抓取） 在没有css的情况下也可以清晰的展示文档内容 利于团队和做和后期维护在日常工作中如何遵循标签语义化 1、尽量减少使用无意义标签，例如span和div； 2、尽量不使用标签本身的css属性，例如b、font、s等标签，如果需要这些样式，那么使用css样式来进行添加； 3、在需要强调的部分，使用strong、em，但是样式尽量使用css样式来描述； 4、表格搭建时，使用&lt;thead&gt;表格头部&lt;/thead&gt; &lt;tbody&gt;表格身体&lt;/tbody&gt; &lt;tfoot&gt;表格尾部&lt;/tfoot&gt;； 5、列表搭建时，使用&lt;ul&gt;无序列表&lt;/ul&gt; &lt;ol&gt;有序列表&lt;/ol&gt; &lt;dl&gt;定义列表&lt;/dl&gt;； 国家评比一个网站的关键点：访问量（流量 点击量） iframe 在引入其他文件的时候，必须写宽度和高度 CSS层叠样式表 css的作用？ css和html怎么结合到一起的？ 在css文件中，如何选择一个html元素，将样式添加给这个元素？ 作用给html文档添加静态或者动态的样式 html引入css的四种方式行内式直接写在标签内，通过标签属性style引入 12&lt;div style="css属性名:属性值;"&gt;&lt;/div&gt;&lt;img style="css属性名:属性值;" alt="" /&gt; 内嵌式（内联式）将css代码写在style元素内，通过css选择器选择html元素，将css样式添加个这个元素 style这个元素，一般放在head元素内 12345&lt;style&gt;div&#123;height:100px;&#125;&lt;/style&gt;&lt;div&gt;&lt;/div&gt; 外联式（外链式）将css代码单独放置在一个css文件中，再通过link标签将这个css文件引入到html文件中1&lt;link rel="stylesheet" href="url" type="text/css"&gt; 导入式@import “url”; 都是引入一个单独的css文件 @import “url”; 既不是html标签，也不是css属性，他是一条声明语句 这条语句必须写在style元素内，或者css文件内 这条语句必须在所在文件内的第一行 123&lt;style&gt;@import "url";&lt;/style&gt; 外联式和导入式的差别： link和@import虽然都是引入外部的css文件，但是他们是由天差地别的区别的 link是html标签，@import完全是css提供的方式，要写在css文件或者style标签中。 他们的加载顺序也是有区别的，当一个页面被加载的时候，link引用的css文件会被同时加载，而@import引入的css文件会等页面全部下载完后再加载。 当使用javascript控制DOM去改变css样式的时候，只能使用link标签，因为import是不能被DOM控制的。 四种引入方式的权重：一个html元素最终加载的css样式是谁决定的有行内式的时候，听行内的在选择器相同的情况下，谁最后加载就听谁的]]></content>
      <tags>
        <tag>html，css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[html+css笔记之一]]></title>
    <url>%2F2015%2F03%2F01%2Fhtml%2Bcss%E7%AC%AC%E4%B8%80%E5%A4%A9%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[前端三层 HTML 结构 是被浏览器直接解析加载 CSS 样式 是在html结构之上去装点网站 javascript 交互 动态效果/数据交互 网页网页是构成网站的基本元素，通俗来讲一个html文件就是一个网页。 网站是由很多个网页组成的，共同为一个目标服务的网页集合。 站群 （流水线统一化管理） 由很多网站组成的，为同一个公司服务。例如整个百度下所属的子公司都有自己的网站，百度搜索、糯米、音乐、手机助手、百度金融…。 HTTP（超文本传输协议）HyperText Transfer Protocol在万维网上提供一种发布和接收HTML页面（网页）的方法步骤： 建立连接：输入网址，建立客户端和服务器端的连接 发送请求信息：客户端发送一个请求给服务器 发送响应信息：服务器接到请求后，给予相应的响应信息 关闭连接：客户端接收服务器所返回的信息通过浏览器显示在用户的显示屏上，然后客户机与服务器断开连接 服务器服务器，是提供计算服务的设备。由于服务器需要响应服务请求，并进行处理，因此一般来说服务器应具备承担服务并且保障服务的能力。 在网络环境下，根据服务器提供的服务类型不同，分为文件服务器，数据库服务器，应用程序服务器，WEB服务器等。 防篡改：web端服务器一旦受到攻击，在0.0n秒作出反应，将内网服务器中的内容，马上覆盖在web端服务器上 负载均衡：平均web服务器压力，将用户访问进行分流 VPN：用来翻墙，有指定账号就可以通过这个产品进行内网访问 浏览器浏览器是指可以显示网页服务器或者文件系统的HTML文件（标准通用标记语言的一个应用）内容，并让用户与这些文件交互的一种软件 html、css、js都是运行在这个软件中，浏览器是一个工厂，html、css、js是工人和原料 IE6 –&gt; IE7(很快淘汰) –&gt; IE8(时间较长，稳定性好) –&gt; IE9(半年-一年) –&gt; IE10 –&gt; IE11 –&gt; IE(Edge) 对开发者最友好的浏览器 –&gt; 谷歌 网页的基本组成HTML：是网页的骨架，支撑起血肉（文字、图片、音视频…）CSS：表皮和衣服、化妆品javascript：动态和交互 HTML （超文本标记语言）网页文件本身是一种文本文件（除了文字再无其他），只有通过特定的标记描述，那些普通文本才能在浏览器中正常的显示，在页面中如果遇到图片，音视频的时候如何用文本描述，需要用超文本进行引入才可以正常显示 html文件的特点浏览器根据标记来解析和描述内容（从html的第一行开始向下解析），如果遇到错误，浏览器不会指出，也不会报错，会跳过此处继续加载，编辑人员需要根据显示效果去分析哪里出错误了 – html不会报错 html的兼容问题因为浏览器是由不同厂商生产的，所以对html的解析有分歧，产生了页面效果显示不一致的情况，我们将这个问题，叫做兼容问题。 超文本 （标签）标签语法由成对的尖括号和关键字(标签名 tagName)组成，叫做标签 &lt;tagName&gt; 关键字（标签名）：是已经规范过的，不是自己随便制造的1234567例如：&lt;亓智&gt;&lt;公维懿&gt;&lt;吕堃鹏&gt;&lt;div&gt;&lt;/h2&gt;&lt;img /&gt; 标签属性属性提供了有关 HTML 元素的更多的信息语法：由属性名和属性值组成（键值对 key=’value’）1234&lt;span style="font-family: 宋体;" title="标题"&gt;span 是标签名style 是标签属性名"font-family: 宋体;" 标签属性值 一个标签可以有很多标签属性，每一个属性之间用空格隔开 标签的分类 开始标签 &lt;div&gt; 结束标签 &lt;/div&gt; 自闭合标签（空标签） &lt;br /&gt; HTML的元素可以将元素理解成一个容器，容器中放置的就是我们网页中的主要内容 内容可以为空 由标签和内容组成的，叫做元素1&lt;div&gt;此处是内容&lt;/div&gt; 元素分类 由开始标签和结束标签组成的元素，可以进行嵌套（一个元素包着另一个元素），元素中可以添加内容 只有一个空标签，只能进行功能的添加，例如 img 元素，用来引入图片，br 用来进行换行 标签和元素是用来标记和描述内容的，所以这些标签和元素用户是看不到的，用户只能看到这个元素中的内容 常用的html元素有哪些 标签名 描述 div 无意义标签 用来区分网页大模块，例如网页头部，主体内容，尾部 span 无意义标签 用来描述行内某个小模块 p 段落 ul 无序列表 ol 有序列表 b 加粗 strong 加粗 浏览器解析的时候 有强调作用 body 身体 网页主体部分 （内容在浏览器的可视区显示） a 超链接 锚点 img 引入图片]]></content>
      <tags>
        <tag>html，css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[预解释]]></title>
    <url>%2F2015%2F03%2F01%2F%E9%A2%84%E8%A7%A3%E9%87%8A%2F</url>
    <content type="text"><![CDATA[预解释:是一个过程,作用域形成之后,代码执行之前,把所有带关键字var和function的提前声明或定义.(也叫做变量提声) 预解释过的东西,在代码执行的时候不会再重复操作 作用域: 全局作用域:window下,一打开浏览器就会形成 私有作用域:一个函数就是一个私有作用域,函数一执行就会形成私有作用域 声明:告诉浏览器这里有个变量,带var关键字的只有声明 定义:赋值过程,在预解释的时候function既声明又定义 预解释的时候遇到变量已经声明过了就不用声明了,但是需要重新定义 预解释的特殊情况 1.=右边不进行预解释(函数作为值的时候) 2.return 下面的代码不执行,但是需要预解释,return后的内容执行但是不进行预解释 12345678910function fn() &#123; var a=0; console.log(f);//fn执行的时候函数f会被输出 return function () &#123;//这个return后面的函数不会被预解释 console.log(1); &#125;; function f() &#123;//此函数在return下面,不会被执行,但是预解释的时候要对其进行预解释. &#125; &#125; 3.条件中,不管条件是否成立{}的代码都进行预解释 注意:var 和function只声明,不定义,声明的时候遇到变量名已经被声明过了,就会报错. 代码执行的时候,条件一旦成立,上来先给函数赋值(函数定义),然后再去执行代码. 123456console.log(num); if(0)&#123; var num=0;//虽然条件不成立,但是需要预解释. &#125; var ss=0;//window.ss=0 console.log("ss" in window);//输出的结果是true,证明"ss"是window的属性 4.自执行函数 不进行预解释 5.函数作为参数的时候不进行预解释 6.预解释的时候遇到已经声明过的变量(函数)不需要声明了,但是需要定义. 注意:全局作用域下的变量就是window的一个属性.带var的预解释声明的时候就给window增加了属性,不带var的执行的时候给window增加属性. 代码执行过程1234console.log(obj1); var obj1=&#123;name:"111"&#125;; console.log(fn); function fn()&#123;&#125;; 1.全局作用域的形成 2.预解释:var obj1, function fn=xxxfff000 3.代码执行: 1)console.log(obj1);此时obj1只声明了没有定义,所以输出的是undefined 1)console.log(obj1);此时obj1只声明了没有定义,所以输出的是undefined 2)obj1=xxxfff111此过程为赋值,引用数据类型赋的值是一个引用地址. 3)console.log(fn);预解释的时候已经被声明和定义,所以直接执行.输出了函数本身内存分类 堆内存:存出东西,一般都是存引用数据类型 栈内存:作用域 私有作用域闭包 闭包:是一种机制,函数执行的时候会形成一个私有作用域,来保护里面的变量不受外界的干扰,我们把这种机制叫做闭包.私有变量 1.参数 2.在私有作用域下预解释的变量. 私有作用域下的私有变量外界访问不到,但是私有作用域可以获取外界的变量. 上级作用域查找查找上一级作用域: 看当前这个函数对应的堆内存是在哪个作用域下定义的,那么他的上一级就是这个作用域,和在哪里执行没有关系. 作用域链在私有作用域下遇到变量先看是不是自己的私有变量(两种),是的话就是私有的,不是的话就是往上一级找,如果还没有,就继续找,知道找到全局位置,还没有找到就报错了,这种查找机制叫做作用域链. 函数的赋值过程: 1.浏览器检测他是什么数据类型的,是函数的话,浏览器就给它开辟一个堆内存 2.将函数当做字符串存起来 3.将地址赋值给函数名 函数执行过程 1.形成私有作用域(只有执行的时候会形成) 2.有形参的话给形参赋值,相当于var一个变量并赋值,function s(a){};s(1)--&gt;a=1 3.预解释 4.函数体执行 内存的销毁机制 1.堆内存:只要这个堆内存没有被任何变量或者属性占用,浏览器就会主动的将他销毁,其他的需要手动销毁,注意以后再做项目的时候遇到一个对象后面不用了,手动清空一下,obj=null; 2.栈内存(作用域): 全局作用域:关闭浏览器的时候销毁,做项目的时候尽量避免全局变量的使用. 私有作用域:相同的函数每一次执行都会形成一个私有的作用域,他们之间没有任何的关系. 1)立即销毁:函数没有返回值,或者返回的内容没有被占用,浏览器就会把它销毁 2)暂时不销毁:函数返回了一个函数,这个返回的函数接着执行了,完了之后浏览器会抽时间销毁(具体什么时候销毁与每个浏览器的机制不一样) 3)不销毁:一,函数执行返回一个地址,一直被外界变量占用着,则私有作用域不销毁;二,在一个私有的作用域中给DOM元素绑定方法,私有作用域不销毁 立即销毁12345678910function fn1() &#123; var n=1; console.log(n++); &#125; fn1(); fn1(); function fn() &#123; console.log("销毁") &#125; fn();//这个函数执行完后,对后面没有什么影响就销毁了. 不销毁1 1234567function fn2() &#123; var n=0; return function () &#123; console.log(n++); &#125; &#125; var f=fn2();//当函数返回一个函数的时候,被外界的变量接收了,作用域不能销毁. 不销毁2123456//作用域不销毁这个概念主要是用在给元素绑定事件的时候.var box=document.getElementById("box"); box.onclick=function () &#123; var n=0; console.log(n) &#125;; 不销毁312345678910var olis=document.getElementsByTagName("ul")[0].getElementsByTagName("li"); for (var i=0;i&lt;olis.length;i++)&#123; olis[i].i=i; olis[i].onclick=(function (j) &#123;//j是自执行函数的形参 return function () &#123; console.log(j); &#125; &#125;)(i);//给自执行函数传入实参(i) &#125; box.onclick=function (e) {} 给元素通过这种方式绑定事件的时候,不要加参数,参数表示的是事件对象]]></content>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[categories]]></title>
    <url>%2Fcategories%2Findex.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[tags]]></title>
    <url>%2Ftags%2Findex.html</url>
    <content type="text"></content>
  </entry>
</search>
